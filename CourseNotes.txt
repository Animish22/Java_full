Java Notes

public class Main {
    public static void main(String[] args) {

        // ‚ùé variable = A reusable container for a value.
        //                          A variable behaves as if it was the value it contains.

        // üü• Primitive = simple value stored directly in memory (stack)
        // üü¶ Reference = memory address (stack) that points to the (heap)

        // üü• Primitive vs üü¶ Reference
        //    ---------                      ---------
        //    int                           string
        //    double                        array
        //    char                          object
        //    boolean

        int age = 21;
        int year = 2025;
        int quantity = 1;

        double price = 19.99;
        double gpa = 3.5;
        double temperature = -12.5;

        char grade = 'A';
        char symbol = '!';
        char currency = '$';

        boolean isStudent = true;
        boolean forSale = false;
        boolean isOnline = true;

        String name = "Bro Code";
        String food = "pizza";
        String email = "fake123@gmail.com";
        String car = "Mustang";
        String color = "red";

        System.out.println("Your choice is a " + color + " " + year + " " + car);
        System.out.println("The price is: " + currency + price);

        if(forSale){
            System.out.println("There is a " + car + " for sale");
        }
        else{
            System.out.println("The " + car + " is not for sale");
        }
    }
}

---------------------------------------------------------------------------------------------------------------------------------------------------
Taking user input 

Scanner class is used to take user input in Java

// Importing Scanner class from util package of java 
import java.util.Scanner;

public class Main {
   public static void main(String[] args) {

       Scanner scanner = new Scanner(System.in); 
       // in --> The "standard" input stream. This stream is already open and ready to supply input data. Typically this stream corresponds to keyboard input or another input source specified by the host environment or user. 

       System.out.println("Enter your name: ");
       String name = scanner.nextLine(); 

       // nextLine -->Advances this scanner past the current line and returns the input that was skipped. This method returns the rest of the current line, excluding any line separator at the end. The position is set to the beginning of the next line.

       System.out.println("Enter your age: ");
       int age = scanner.nextInt();
       // nextInt --> Scans the next token of the input as an int.

       System.out.println("What is your gpa: ");
       double gpa = scanner.nextDouble();
       // nextDouble --> Scans the next token of the input as a double. This method will throw InputMismatchException if the next token cannot be translated into a valid double value. If the translation is successful, the scanner advances past the input that matched.

       System.out.println("Are you a student? (true/false): ");
       boolean isStudent = scanner.nextBoolean();
       // nextBoolean --> Scans the next token of the input into a boolean value and returns that value. This method will throw InputMismatchException if the next token cannot be translated into a valid boolean value. If the match is successful, the scanner advances past the input that matched.

       System.out.println("Hello " + name);
       System.out.println("You are " + age + " years old");
       System.out.println("Your gpa is: " + gpa);

       if(isStudent){
           System.out.println("You are enrolled in classes");
       }
       else{
           System.out.println("You are NOT enrolled in classes");
      }

       scanner.close(); 
       // If this scanner has not yet been closed then if its underlying readable also implements the java.io.Closeable interface then the readable's close method will be invoked. If this scanner is already closed then invoking this method will have no effect.
   }
}

--------------------------------------------------------------------------------------------------------------------------------------------------------------

Arithmetic Operations 

public class Main {
    public static void main(String[] args) {

        // Arithmetic Operators

        int x = 10;
        int y = 2;
        int z;

        z = x + y; // ADDITION
        z = x - y; // SUBTRACTION
        z = x * y; // MULTIPLICATION
        z = x / y; // DIVISION
        z = x % y; // MODULUS

        x += y; // SHORT HAND OPERATIONS ARE ALSO AVAILABLE

        x++ // UNARY OPERATIONS ARE ALSO AVAILABLE

        System.out.println(z);

    }
}

------------------------------------------------------------------------------------------------------------------------------------------------------------------

// if statement = performs a block of code if its condition is true

int age = 20 ; 
if(age < 10){
    System.out.println("You are a Child! üè´");
}
else if(age < 20){
    System.out.println("You are  a student üè¢");
}
else
{
    System.out.println("You are grown up!")
}

--------------------------------------------------------------------------------------------------------------------------------------------------------

Generating Random Numbers 

import java.util.Random;

public class Main {
    public static void main(String[] args) {
        
        Random random = new Random();
        
        int number;
        boolean isHeads;

        number = random.nextInt(1, 7);
        
        isHeads = random.nextBoolean();

        System.out.println(number);
        
        if(isHeads){
            System.out.println("HEADS");
        }
        else{
            System.out.println("TAILS");
        }
    }
}

----------------------------------------------------------------------------------------------------------------------------------------------------------------

Basic Math Expressions and their usage

public class Main {
   public static void main(String[] args) {

       System.out.println(Math.PI);
       System.out.println(Math.E);

       double result;

       result = Math.pow(3, 4);
       result = Math.abs(-5);
       result = Math.sqrt(16);
       result = Math.round(3.14);
       result = Math.ceil(3.14);
       result = Math.floor(3.14);
       result = Math.max(10, 20);
       result = Math.min(10, 20);

       System.out.println(result);
   }
}

import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        
        Scanner scanner = new Scanner(System.in);

        double a;
        double b;
        double c;

        System.out.print("Enter the length of side A: ");
        a = scanner.nextDouble();

        System.out.print("Enter the length of side B: ");
        b = scanner.nextDouble();

        c = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));

        System.out.println("The hypotenuse is: " + c + "cm");

        scanner.close();
    }
}

import java.util.Scanner;

public class Main {
    public static void main(String[] args) {

        // circumference = 2 * Math.PI * radius;
        // area = Math.PI * Math.pow(radius, 2);
        // volume = (4.0 / 3.0) * Math.PI * Math.pow(radius, 3)

        Scanner scanner = new Scanner(System.in);

        double radius;
        double circumference;
        double area;
        double volume;

        System.out.print("Enter the radius: ");
        radius = scanner.nextDouble();

        circumference = 2 * Math.PI * radius;
        area = Math.PI * Math.pow(radius, 2);
        volume = (4.0 / 3.0) * Math.PI * Math.pow(radius, 3);

        System.out.printf("The circumference is: %.1fcm\n", circumference);
        System.out.printf("The area is: %.1fcm¬≤\n", area);
        System.out.printf("The volume is: %.1fcm¬≥\n", volume);

        scanner.close();
    }
}
----------------------------------------------------------------------------------------------------------------------------------------------------------

Using printf in Java 

public class Main {
   public static void main(String[] args) {
      
       // printf() is a method used to format output

       // % [flags] [width] [.precision] [specifier-character]

       // [specifier-character]

       String name = "Spongebob";
       char firstLetter = 'S';
       int age = 30;
       double height = 60.5;
       boolean isEmployed = true;

       System.out.printf("Hello %s\n", name);
       System.out.printf("Your name starts with a %c\n", firstLetter);
       System.out.printf("You are %d years old\n", age);
       System.out.printf("You are %f inches tall\n", height);
       System.out.printf("Employed: %b\n", isEmployed);

       System.out.printf("%s is %d years old", name, age);

       // [.precision]

       double price1 = 9.99;
       double price2 = 100.15;
       double price3 = -54.01;

       // %.3f shows three digits after decimal for the variable price1
       System.out.printf("%.3f\n", price1); 
       System.out.printf("%.3f\n", price2);
       System.out.printf("%.3f\n", price3);

       // [flags]

       // + = output a plus
       // , = comma grouping separator
       // ( = negative numbers are enclosed in ()
       // space = display a minus if negative, space if positive

       comma grouping separator is used to separate large numbers with commas
       System.out.printf("%,.2f\n", price1);

       () is used to enclose negative numbers
       System.out.printf("%(.2f\n", price1));

       System.out.printf("%f\n", price1);
       System.out.printf("%f\n", price2);
       System.out.printf("%f\n", price3);

       // [width]

       // 0 = zero padding
       // number = right justified padding
       // negative number = left justified padding

       int id1 = 1;
       int id2 = 23;
       int id3 = 456;
       int id4 = 7890;

       System.out.printf("id: %04d\n", id1); --> 0001
       System.out.printf("id: %04d\n", id2); --> 0023 
       System.out.printf("id: %04d\n", id3); --> 0456
       System.out.printf("id: %04d\n", id4); --> 7890

   }
}

---------------------------------------------------------------------------------------------------------------------------------------------------------------

String methods in Java 

public class Main {
    public static void main(String[] args) {

        String name = "Bro Code";

        int length = name.length();
        char letter = name.charAt(0);
        int index = name.indexOf(" ");
        int lastIndex = name.lastIndexOf("o");

        name = name.toUpperCase();
        name = name.toLowerCase();
        name = name.trim();
        name = name.replace("o", "a");
        
        if(name.isEmpty()){
            System.out.println("Your name is empty");
        }
        else{
            System.out.println("Hello " + name);
        }

        if(name.contains(" ")){
            System.out.println("Your name contains a space");
        }
        else{
            System.out.println("Your name DOESN'T contain any spaces");
        }

        if(name.equals("password")){
            System.out.println("Your name can't be password");
        }
        else{
            System.out.println("Hello " + name);
        }

        if(name.equalsIgnoreCase("password")){
            System.out.println("Your name can't be password");
        }
        else{
            System.out.println("Hello " + name);
        }
    }
}

import java.util.Scanner;

public class Main {
    public static void main(String[] args) {

        // .substring() = A method used to extract a portion of a string
        //                         .substring(start, end)

        Scanner scanner = new Scanner(System.in);

        String email;
        String username;
        String domain;

        System.out.print("Enter your email: ");

        email = scanner.nextLine();

        if(email.contains("@")){
            username = email.substring(0, email.indexOf("@"));
            domain = email.substring(email.indexOf("@") + 1); 
            // If end is not defined it gets the entire string after the start index .

            System.out.println(username);
            System.out.println(domain);
        }
        else{
            System.out.println("Emails must contain @");
        }

        scanner.close();
    }
}

-------------------------------------------------------------------------------------------------------------------------------------------------------

Ternary Operator 

public class Main {
   public static void main(String[] args) {

       // ternary operator ? = Return 1 of 2 values if a condition is true

       // variable = (condition) ? IfTrue : IfFalse;

       int number = 10;
 
       String evenOrOdd = (number % 2 == 0) ? "EVEN" : "ODD";

   }
}

------------------------------------------------------------------------------------------------------------------------------------------------------------------

Switch Case in Java 

import java.util.Scanner;
public class Main {
    public static void main(String[] args) {

        // switch case = A control flow statement that executes a block of code based on the value of a variable

        Scanner scanner = new Scanner(System.in);

        System.out.print("Enter a number (1-7): ");
        int day = scanner.nextInt();

        String dayName;

        switch(day){
            case 1:
                dayName = "Monday";
                break;
            case 2:
                dayName = "Tuesday";
                break;
            case 3:
                dayName = "Wednesday";
                break;
            case 4:
                dayName = "Thursday";
                break;
            case 5:
                dayName = "Friday";
                break;
            case 6:
                dayName = "Saturday";
                break;
            case 7:
                dayName = "Sunday";
                break;
            default:
                dayName = "Invalid Day";
        }

        System.out.println("Day: " + dayName);

        scanner.close();
    }
}

Shorthand

import java.util.Scanner;
public class Main {
    public static void main(String[] args) {

        // switch case = A control flow statement that executes a block of code based on the value of a variable

        Scanner scanner = new Scanner(System.in);

        System.out.print("Enter a number (1-7): ");
        int day = scanner.nextInt();

        String dayType = switch(day) {
            case 1 ,2 ,3 ,4 ,5 -> "Weekday";
            case 6, 7 -> "Weekend";
            default -> "Invalid Day";
        };

        System.out.println("Day: " + dayType);

        scanner.close();
    }
}

---------------------------------------------------------------------------------------------------------------------------------------------------------------

Logical Operators in Java

public class Main {
    public static void main(String[] args) {

        // Logical Operators = Used to combine multiple boolean expressions

        // && = AND
        // || = OR
        // ! = NOT

        boolean isStudent = true;
        boolean isAdult = false;

        if(isStudent && isAdult){
            System.out.println("You are a student and an adult");
        }
        else if(isStudent || isAdult){
            System.out.println("You are either a student or an adult");
        }
        else{
            System.out.println("You are neither a student nor an adult");
        }

        if(!isStudent){
            System.out.println("You are not a student");
        }
    }
}

--------------------------------------------------------------------------------------------------------------------------------------------------------------

While Loop 

import java.util.Scanner;

public class Main {
   public static void main(String[] args) {

       Scanner scanner = new Scanner(System.in);

       // EXAMPLE 1

       String name = "";

       while(name.isEmpty()){
           System.out.print("Enter your name: ");
           name = scanner.nextLine();
       }

       System.out.println("Hello " + name);

       // EXAMPLE 2

       String response = "";

       while(!response.equals("Q")){
           System.out.print("Press Q to quit: ");
           response = scanner.next().toUpperCase();
       }

       System.out.println("You have quit");

       scanner.close();
   }
}

----------------------------------------------------------------------------------------------------------------------------------------------------------------

For Loop

import java.util.Scanner;

public class Main {
    public static void main(String[] args) throws InterruptedException {

        // for loop = execute some code a CERTAIN amount of times

        Scanner scanner = new Scanner(System.in);

        System.out.print("How many seconds to countdown from?: ");
        int start = scanner.nextInt();

        for(int i = start; i > 0; i--){
            System.out.println(i);
            Thread.sleep(1000);
        }

        System.out.println("HAPPY NEW YEAR!");
    }
}

---------------------------------------------------------------------------------------------------------------------------------------------------------------
For Each Loop

import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
public class Main {
    public static void main(String[] args) {

        // for each loop = A control flow statement that iterates through elements in a collection or array

        List<String> names = new ArrayList<>();
        names.add("Bro");
        names.add("Code");
        names.add("Java");

        for(String name : names){
            System.out.println(name);
        }

        // EXAMPLE 2

        Scanner scanner = new Scanner(System.in);

        System.out.print("How many names do you want to enter?: ");
        int count = scanner.nextInt();
        scanner.nextLine(); // Consume the newline character

        List<String> userNames = new ArrayList<>();

        for(int i = 0; i < count; i++){
            System.out.print("Enter name " + (i + 1) + ": ");
            userNames.add(scanner.nextLine());
        }

        for(String userName : userNames){
            System.out.println(userName);
        }

        scanner.close();
    }
}

---------------------------------------------------------------------------------------------------------------------------------------------------------------

Methods 

public class Main {
    public static void main(String[] args){

        // method =  a block of reusable code that is executed when called ()

        happyBirthday("Spongebob", 30);
    }

    static void happyBirthday(String name, int age){
        System.out.println("Happy Birthday to you!");
        System.out.printf("Happy Birthday dear %s!\n", name);
        System.out.printf("You are %d years old!\n", age);
        System.out.println("Happy Birthday to you!\n");
    }

    static double square(double number){
        return number * number;
    }

    static double cube(double number){
        return number * number * number;
    }

    static String getFullName(String first, String last){
        return first + " " + last;
    }

    static boolean ageCheck(int age){
        if(age >= 18){
            return true;
        }
        else{
            return false;
        }
    }
}

----------------------------------------------------------------------------------------------------------------------------------------------------------------

// Method Overloading

public class Main {
    public static void main(String[] args){

        // overloaded methods = methods that share the same name,
        //                                          but different parameters
        //                                          signature = name + parameters

        String pizza = bakePizza("flat-bread", "mozzarella", "pepperoni");

        System.out.println(pizza);

    }
    static String bakePizza(String bread){
        return bread + " pizza";
    }
    static String bakePizza(String bread, String cheese){
        return cheese + " " + bread + " pizza";
    }
    static String bakePizza(String bread, String cheese, String topping){
        return topping + " " + cheese + " " + bread + " pizza";
    }
}

--------------------------------------------------------------------------------------------------------------------------------------------------------------

Variable Scope

public class Main {
    public static void main(String[] args) {

        // variable scope = The region of the program where a variable is accessible

        int x = 1; // Global variable

        if(x > 0){
            int y = 2; // Local variable
            System.out.println("x is greater than 0");
            System.out.println("y: " + y);
        }

        System.out.println("x: " + x);
        // System.out.println("y: " + y); // This will cause an error because y is not accessible here
    }
}

Class scope 

{
    static int x = 1; // Class Scope can be accessed by all methods in the class

    public static void main(String[] args) {
        System.out.println("x: " + x);
        method1();
        method2();
    }

    static void method1() {
        int y = 2; // Local variable
        System.out.println("y: " + y);
    }

    static void method2() {
        // System.out.println("y: " + y); // This will cause an error because y is not accessible here
        System.out.println("x: " + x); // x is accessible here
    }
}

---------------------------------------------------------------------------------------------------------------------------------------------------------------

Arrays 

import java.util.Arrays;

public class Main {

    public static void main(String[] args){

        // array = a collection of values of the same data type
        //              * think of it as a variable that can store more than 1 value *

        String[] fruits = {"apple", "orange", "banana", "coconut"};

        //fruits[0] = "pineapple";
        //int numOfFruits = fruits.length;
        //Arrays.sort(fruits);
        //Arrays.fill(fruits, "pineapple");

        for(String fruit : fruits){
            System.out.println(fruit);
        }
    }
}

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


Taking User input for Arrays 

import java.util.Scanner;

public class Main {
    public static void main(String[] args){

        Scanner scanner = new Scanner(System.in);
        int size;

        System.out.print("What # of food do you want?: ");
        size = scanner.nextInt();
        scanner.nextLine();

        String[] foods = new String[size];

        for(int i = 0; i < foods.length; i++){
            System.out.print("Enter a food: ");
            foods[i] = scanner.nextLine();
        }

        for(String food : foods){
            System.out.println(food);
        }

        scanner.close();
    }
}

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Searching through an Array 

import java.util.Scanner;

public class Main {
    public static void main(String[] args){

        Scanner scanner = new Scanner(System.in);

        String[] fruits = {"apple", "orange", "banana"};
        boolean isFound = false;
        String target;

        System.out.print("Enter a fruit to search for: ");
        target = scanner.nextLine();

        for(int i = 0; i < fruits.length; i++){
            if(fruits[i].equals(target)){
                System.out.println("Element found at index: " + i);
                isFound = true;
                break;
            }
        }

        if(!isFound){
            System.out.println("Element not found in the array");
        }

        scanner.close();
    }
}

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

VARARGS (Variable Arguments)

public class Main {
    public static void main(String[] args){

        // varargs = allow a method to accept a varying # of arguments
        //                  makes methods more flexible, no need for overloaded methods
        //                  java will pack the arguments into an array
        //                  ... (ellipsis)

        System.out.println(average(1, 2, 3, 4));

    }
    static double average(double... numbers){

        double sum = 0;

        if(numbers.length == 0){
            return 0;
        }

        for(double number : numbers){
            sum += number;
        }

        return sum / numbers.length;
    }
}

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Multideimensional Arrays

public class Main {
    public static void main(String[] args){

        // 2D array = An array where each element is an array
        //                    Useful for storing a matrix of data

        //-----------------------
        //   EXAMPLE 1
        //-----------------------
        
        String[][] groceries = {{"apple", "orange", "banana"},
                                              {"potato", "onion", "carrot"},
                                              {"chicken", "pork", "beef", "fish"}};

        groceries[2][1] = "eggs";

        for(String[] foods : groceries){
            for(String food : foods){
                System.out.print(food + " ");
            }
            System.out.println();
        }

        //-----------------------
        //   EXAMPLE 2
        //-----------------------

        char[][] telephone = {{'1', '2', '3'},
                                            {'4', '5', '6'},
                                            {'7', '8', '9'},
                                            {'*', '0', '#'}};

        for(char[] row : telephone){
            for(char number : row){
                System.out.print(number + " ");
            }
            System.out.println();
        }
    }
}

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Java Slot Machine Project

import java.util.Random;
import java.util.Scanner;

public class Main {
    public static void main(String[] args){

        // JAVA SLOT MACHINE

        Scanner scanner = new Scanner(System.in);
        int balance = 100;
        int bet;
        int payout;
        String[] row;
        String playAgain;

        System.out.println("*************************");
        System.out.println("  Welcome to Java Slots  ");
        System.out.println("Symbols: üçí üçâ üçã üîî ‚≠ê ");
        System.out.println("*************************");

        while(balance > 0){
            System.out.println("Current balance: $" + balance);
            System.out.print("Place your bet amount: ");
            bet = scanner.nextInt();
            scanner.nextLine();

            if(bet > balance){
                System.out.println("INSUFFICIENT FUNDS");
                continue;
            }
            else if(bet <= 0){
                System.out.println("Bet must be greater than 0");
                continue;
            }
            else{
                balance -= bet;
            }

            System.out.println("Spinning...");
            row = spinRow();
            printRow(row);
            payout = getPayout(row, bet);

            if(payout > 0){
                System.out.println("You won $" + payout);
                balance += payout;
            }
            else{
                System.out.println("Sorry you lost this round");
            }

            System.out.print("Do you want to play again? (Y/N): ");
            playAgain = scanner.nextLine().toUpperCase();

            if(!playAgain.equals("Y")){
                break;
            }
        }

        System.out.println("GAME OVER! Your final balance is $" + balance);

        scanner.close();
    }
    static String[] spinRow(){

        String[] symbols = {"üçí", "üçâ", "üçã", "üîî", "‚≠ê"};
        String[] row = new String[3];
        Random random = new Random();

        for(int i = 0; i < 3; i++){
            row[i] = symbols[random.nextInt(symbols.length)];
        }

        return row;
    }
    static void printRow(String[] row){
        System.out.println("**************");
        System.out.println(" " + String.join(" | ", row));
        System.out.println("**************");
    }
    static int getPayout(String[] row, int bet){

        if(row[0].equals(row[1]) && row[1].equals(row[2])){
            return switch(row[0]){
                case "üçí" -> bet * 3;
                case "üçâ" -> bet * 4;
                case "üçã" -> bet * 5;
                case "üîî" -> bet * 10;
                case "‚≠ê" -> bet * 20;
                default -> 0;
            };
        }
        else if(row[0].equals(row[1])){
            return switch(row[0]){
                case "üçí" -> bet * 2;
                case "üçâ" -> bet * 3;
                case "üçã" -> bet * 4;
                case "üîî" -> bet * 5;
                case "‚≠ê" -> bet * 10;
                default -> 0;
            };
        }
        else if(row[1].equals(row[2])){
            return switch(row[1]){
                case "üçí" -> bet * 2;
                case "üçâ" -> bet * 3;
                case "üçã" -> bet * 4;
                case "üîî" -> bet * 5;
                case "‚≠ê" -> bet * 10;
                default -> 0;
            };
        }

        return 0;
    }
}

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Recursion in Java

public class Main {
    public static void main(String[] args) {

        // recursion = A method that calls itself to solve a problem
        //                      Useful for solving problems that can be broken down into smaller subproblems

        int number = 5;
        int factorial = factorial(number);

        System.out.println("Factorial of " + number + " is: " + factorial);
    }

    static int factorial(int n){
        if(n == 0 || n == 1){
            return 1;
        }
        return n * factorial(n - 1);
    }
}

--------------------------------------------------------------------------------------------------------------------------------------------------------------

Object Oriented Programming in Java 

Object-Oriented Programming (OOP) is a programming paradigm based on the concept of "objects," which can contain data and code: data in the form of fields (attributes or properties), and code in the form of procedures (methods or behaviors).

Java is an object-oriented language, and understanding its OOPs principles is fundamental to writing effective and maintainable Java code. Let's explore these concepts in an order suitable for a first-time learner, with detailed explanations and examples.

---

## 1. Introduction to OOPs in Java

**What is OOPs?**
OOPs stands for **Object-Oriented Programming System**. It's a way of designing and organizing your code around **objects** rather than just functions or logic. Think of it as modeling real-world entities and their interactions within your software.

**Why OOPs?**
1.  **Real-world Modeling:** It helps map real-world problems into software solutions more intuitively.
2.  **Reusability:** Code written once can be reused multiple times.
3.  **Maintainability:** Changes in one part of the system have minimal impact on others.
4.  **Scalability:** Easier to add new features or expand functionality.
5.  **Security:** Data hiding protects sensitive information.

**The Four Pillars of OOPs:**
While we'll discuss them in detail, the four core principles are:
* **Encapsulation:** Bundling data and methods that operate on the data.
* **Inheritance:** Creating new classes based on existing ones.
* **Abstraction:** Hiding complex implementation details, showing only essential features.
* **Polymorphism:** The ability of an object to take on many forms.

---

## 2. Classes and Objects (The Foundation)

**Classes:**
A **class** is a blueprint, a template, or a prototype from which objects are created. It's a logical entity that defines the common properties (data) and behaviors (methods) that all objects of that type will have. You can't directly "do" anything with a class; it's just a definition.

* **Fields (Attributes/Properties/Data):** Variables declared within a class, representing the characteristics of an object.
* **Methods (Behaviors/Functions):** Functions declared within a class, representing actions an object can perform.

**Objects:**
An **object** is a real-world entity, a physical entity, and an instance of a class. When you create an object from a class, you are essentially bringing that blueprint to life. Each object has its own unique set of field values.

* **Syntax to create an object:** `ClassName objectName = new ClassName();`
    * `new`: The keyword used to create a new object.
    * `ClassName()`: Calls the class's constructor (we'll cover this next).

**Example: `Dog` Class and `myDog` Object**

```java
// Dog.java - A class definition
class Dog {
    // Fields (Attributes)
    String name;
    String breed;
    int age;

    // Method (Behavior)
    void bark() {
        System.out.println(name + " says Woof!");
    }

    void eat() {
        System.out.println(name + " is eating.");
    }
}

// Practice.java - Where we create and use Dog objects
public class Practice {
    public static void main(String[] args) {
        // Creating an object (an instance of the Dog class)
        Dog myDog = new Dog();

        // Assigning values to object's fields
        myDog.name = "Buddy";
        myDog.breed = "Golden Retriever";
        myDog.age = 3;

        // Calling object's methods
        myDog.bark(); // Output: Buddy says Woof!
        myDog.eat();  // Output: Buddy is eating.

        // Creating another Dog object
        Dog anotherDog = new Dog();
        anotherDog.name = "Lucy";
        anotherDog.breed = "Labrador";
        anotherDog.age = 5;

        anotherDog.bark(); // Output: Lucy says Woof!
    }
}
```

---

## 3. Constructors

A **constructor** is a special type of method that is used to **initialize** objects. It gets called automatically when an object is created using the `new` keyword.

**Key Characteristics of Constructors:**
* It has the **same name as its class**.
* It **does not have a return type** (not even `void`).
* It cannot be called explicitly; it's invoked automatically during object creation.

**Types of Constructors:**

* **Default Constructor (No-arg Constructor):**
    If you don't define any constructor in your class, Java automatically provides a public, no-argument constructor. It initializes instance variables with default values (e.g., `null` for objects, `0` for numbers, `false` for booleans).

* **Parameterized Constructor:**
    A constructor that takes one or more arguments. This allows you to initialize an object's fields with specific values at the time of creation.

* **Constructor Overloading:**
    A class can have multiple constructors, as long as they have different parameter lists (different number of parameters, different types of parameters, or different order of parameters). This is an example of compile-time polymorphism.

**Example: `Dog` Class with Constructors**

```java
class Dog {
    String name;
    String breed;
    int age;

    // 1. Default Constructor (No-arg) - If you don't define any, Java provides one
    // Dog() {
    //     System.out.println("A new dog is born (default constructor)");
    // }

    // 2. Parameterized Constructor
    Dog(String name, String breed, int age) {
        System.out.println("Parameterized constructor called for " + name);
        this.name = name;  // 'this.name' refers to the instance variable
        this.breed = breed;
        this.age = age;
    }

    // 3. Constructor Overloading (e.g., if age is unknown)
    Dog(String name, String breed) {
        System.out.println("Overloaded constructor called for " + name);
        this.name = name;
        this.breed = breed;
        this.age = 0; // Default age if not provided
    }

    void bark() {
        System.out.println(name + " says Woof!");
    }
}

public class Practice {
    public static void main(String[] args) {
        // Using the parameterized constructor
        Dog myDog = new Dog("Buddy", "Golden Retriever", 3);
        myDog.bark(); // Output: Buddy says Woof!

        // Using the overloaded constructor
        Dog newPuppy = new Dog("Max", "Beagle");
        newPuppy.bark(); // Output: Max says Woof!
        System.out.println(newPuppy.age); // Output: 0 (defaulted by constructor)
    }
}
```

---

## 4. `this` Keyword

The `this` keyword in Java is a reference variable that refers to the **current object**. It's primarily used in a few contexts:

1.  **To differentiate between instance variables and local variables (when they have the same name):**
    This is very common in parameterized constructors and setter methods.

2.  **To invoke the current class's constructor (constructor chaining):**
    You can use `this()` to call another constructor from the same class. This is useful to avoid code duplication when you have multiple constructors. It **must be the first statement** in the constructor.

3.  **To refer to the current class instance (implicitly in methods):**
    Methods always operate on an instance, and `this` is implicitly passed.

**Example: `this` keyword in `Dog` Class**

```java
class Dog {
    String name;
    String breed;
    int age;

    // Parameterized Constructor
    Dog(String name, String breed, int age) {
        // 'this.name' refers to the instance variable 'name' of the current object.
        // 'name' on the right side refers to the local parameter 'name'.
        this.name = name;
        this.breed = breed;
        this.age = age;
    }

    // Constructor Overloading (using 'this()' for chaining)
    Dog(String name, String breed) {
        // Calls the 'Dog(String name, String breed, int age)' constructor with age=0
        this(name, breed, 0); // Must be the first statement in this constructor
        System.out.println("Overloaded constructor finished initialization for " + this.name);
    }

    void setName(String name) {
        this.name = name; // Differentiate local 'name' from instance 'name'
    }

    void printDetails() {
        System.out.println("Name: " + this.name + ", Breed: " + this.breed + ", Age: " + this.age);
    }
}

public class Practice {
    public static void main(String[] args) {
        Dog myDog = new Dog("Buddy", "Golden Retriever", 3);
        myDog.printDetails(); // Output: Name: Buddy, Breed: Golden Retriever, Age: 3

        Dog newPuppy = new Dog("Max", "Beagle"); // Uses the overloaded constructor
        newPuppy.printDetails(); // Output: Name: Max, Breed: Beagle, Age: 0
    }
}
```

---

## 5. Encapsulation

**Encapsulation** is one of the fundamental principles of OOPs. It's the mechanism of **bundling the data (fields) and the methods (behaviors) that operate on that data into a single unit (a class)**. It also involves **data hiding**, meaning the internal state of an object is hidden from the outside world, and external access to the data is only allowed through well-defined public methods (getters and setters).

**Benefits of Encapsulation:**
* **Data Hiding:** Protects data from unauthorized access or modification.
* **Flexibility:** Allows changes to the internal implementation of a class without affecting code that uses the class.
* **Maintainability:** Easier to debug and update code.

### Access Modifiers (Key to Encapsulation)

Access modifiers control the visibility of a class, its fields, methods, and constructors.

* **`private`**:
    * **Visibility:** Accessible only within the same class.
    * **Use Case:** Ideal for instance variables (data) to achieve data hiding.

* **`default` (no keyword):**
    * **Visibility:** Accessible only within the same package.
    * **Use Case:** When you want classes within the same package to cooperate closely, but hide from outside packages.

* **`protected`**:
    * **Visibility:** Accessible within the same package AND by subclasses (even if in a different package).
    * **Use Case:** For members that subclasses might need to access or override, but which should still be somewhat hidden from the general public.

* **`public`**:
    * **Visibility:** Accessible from anywhere (all classes, all packages).
    * **Use Case:** Typically for methods that provide an interface for interacting with the object (e.g., getters, setters, main methods).

**Example: `Student` Class with Encapsulation**

```java
// Student.java
package myproject.app;

class Student {
    // Private fields - Data hiding achieved
    private String name;
    private int age;
    private String studentId;

    // Constructor to initialize the object
    public Student(String name, int age, String studentId) {
        this.name = name;
        this.age = age;
        this.studentId = studentId;
    }

    // Public Getter methods - Allow reading the data
    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    public String getStudentId() {
        return studentId;
    }

    // Public Setter methods - Allow modifying the data with control
    public void setName(String name) {
        // You can add validation here, e.g., if (name != null && !name.isEmpty())
        this.name = name;
    }

    public void setAge(int age) {
        // You can add validation here, e.g., if (age > 0 && age < 120)
        this.age = age;
    }
    // No setter for studentId if it should be immutable after creation
}

public class Practice {
    public static void main(String[] args) {
        // Create a student object
        Student s1 = new Student("Alice", 20, "S1001");

        // Access data using public getter methods
        System.out.println("Student Name: " + s1.getName()); // Output: Student Name: Alice
        System.out.println("Student Age: " + s1.getAge());   // Output: Student Age: 20

        // Try to access private field directly (will cause compilation error)
        // System.out.println(s1.name); // ERROR: The field Student.name is not visible

        // Modify data using public setter methods
        s1.setAge(21);
        System.out.println("Student New Age: " + s1.getAge()); // Output: Student New Age: 21
    }
}
```

---

## 6. Inheritance

**Inheritance** is an OOPs mechanism where one class can acquire the properties (fields) and behaviors (methods) of another class. It promotes **code reusability** and establishes an "is-a" relationship (e.g., a `Car` *is a* `Vehicle`).

* **Parent Class / Superclass / Base Class:** The class whose features are inherited.
* **Child Class / Subclass / Derived Class:** The class that inherits features from another class.
* **`extends` keyword:** Used to indicate inheritance in Java.

**Key Concepts in Inheritance:**
* A subclass inherits all public and protected members of its superclass. It also inherits default (package-private) members if both classes are in the same package. Private members are NOT inherited, but can be accessed indirectly through public/protected methods of the superclass.
* Java supports **single inheritance** (a class can only extend one direct superclass).
* **Method Overriding:** A subclass can provide a specific implementation for a method that is already defined in its superclass. This is a key aspect of runtime polymorphism.

**Example: `Vehicle` -> `Car` Inheritance**

```java
// Vehicle.java (Parent Class)
package myproject.app;

class Vehicle {
    String brand;
    int year;

    public Vehicle(String brand, int year) {
        this.brand = brand;
        this.year = year;
    }

    public void start() {
        System.out.println("Vehicle started.");
    }

    public void stop() {
        System.out.println("Vehicle stopped.");
    }

    public void displayInfo() {
        System.out.println("Brand: " + brand + ", Year: " + year);
    }
}

// Car.java (Child Class) extends Vehicle
package myproject.app;

class Car extends Vehicle { // Car inherits from Vehicle
    String model;

    // Constructor for Car
    public Car(String brand, int year, String model) {
        // Call the superclass (Vehicle) constructor
        super(brand, year); // <--- We'll explain 'super' next!
        this.model = model;
    }

    // Car-specific method
    public void drive() {
        System.out.println(model + " is driving.");
    }

    // Method Overriding: Providing a specific implementation for displayInfo
    @Override // Optional, but highly recommended annotation
    public void displayInfo() {
        // Calling the superclass's displayInfo method
        super.displayInfo(); // <--- We'll explain 'super' next!
        System.out.println("Model: " + model);
    }
}

public class Practice {
    public static void main(String[] args) {
        // Create a Vehicle object
        Vehicle v1 = new Vehicle("Generic Motors", 2020);
        v1.displayInfo(); // Output: Brand: Generic Motors, Year: 2020
        v1.start();       // Output: Vehicle started.

        System.out.println("---");

        // Create a Car object
        Car c1 = new Car("Ford", 2023, "Mustang");
        c1.displayInfo(); // Output:
                          // Brand: Ford, Year: 2023
                          // Model: Mustang
        c1.start();       // Output: Vehicle started. (inherited method)
        c1.drive();       // Output: Mustang is driving. (Car-specific method)
    }
}
```

---

## 7. `super` Keyword (Specifically `super()` Constructor)

The `super` keyword in Java is a reference variable that refers to the immediate parent class (superclass) object. It's used to access members (fields and methods) of the superclass that might be hidden by members of the subclass, or to invoke a superclass's constructor.

**Main Usages of `super`:**

1.  **`super()`: To invoke the superclass's constructor.**
    * This is the most common and crucial use. When you create an object of a subclass, the constructor of the superclass is always called first (implicitly or explicitly).
    * If the superclass has a no-argument constructor, Java implicitly calls `super()` if you don't explicitly call any `super()` constructor in your subclass constructor.
    * If the superclass only has parameterized constructors, you *must* explicitly call `super(arguments)` from the subclass constructor.
    * **Rule:** `super()` (or `super(arguments)`) must be the **first statement** in the subclass constructor.

2.  **`super.methodName()`: To invoke a superclass method.**
    * Useful when a subclass has overridden a method, but you still want to call the superclass's version of that method.

3.  **`super.fieldName`: To refer to a superclass instance variable.**
    * Useful when a subclass has a field with the same name as a superclass field, and you want to access the superclass's version.

**Example: `super()` in `Car` Constructor and `super.method()` in `displayInfo()`**

(This continues from the `Vehicle` and `Car` example in the Inheritance section)

```java
// Car.java (Child Class)
package myproject.app;

class Car extends Vehicle {
    String model;

    public Car(String brand, int year, String model) {
        // Calling the superclass (Vehicle) constructor
        // This MUST be the first statement in the constructor
        super(brand, year); // Invokes Vehicle's constructor: Vehicle(String brand, int year)
        this.model = model;
        System.out.println("Car constructor called for " + model);
    }

    @Override
    public void displayInfo() {
        // Calling the superclass's displayInfo method first
        super.displayInfo(); // Invokes Vehicle's displayInfo()
        System.out.println("Model: " + model);
    }
}

// In Practice.java (main method is unchanged from previous example)
// ... (code will run same as before, demonstrating super()'s implicit call and super.displayInfo() explicit call)
```

---

## 8. `static` Keyword

The `static` keyword is used for members (fields, methods, nested classes, blocks) that belong to the **class itself**, rather than to any particular instance (object) of the class.

* **`static` members are loaded when the class is loaded**, before any objects of that class are created.
* They are shared by all objects of that class.
* You access `static` members using the class name, not an object reference.

**Usages of `static`:**

1.  **`static` Field (Class Variable):**
    * A single copy of the variable is shared among all instances of the class.
    * Accessed via `ClassName.fieldName`.
    * Example: `Math.PI`, `Integer.MAX_VALUE`.

2.  **`static` Method (Class Method):**
    * Belongs to the class, not an object.
    * Can be called directly using `ClassName.methodName()`.
    * **Cannot access non-static (instance) members directly.** Because `static` methods exist before any objects, they don't have a `this` reference to an object.
    * Can only call other `static` methods or access `static` fields.
    * Example: `Math.sqrt()`, `System.out.println()`.

3.  **`static` Block:**
    * A block of code that is executed exactly once when the class is loaded into the JVM.
    * Used for static initialization (e.g., setting up `static` fields).

4.  **`static` Nested Class:**
    * A nested class (a class defined inside another class) that is declared `static`.
    * It doesn't require an outer class instance to be created.
    * Can only access static members of the outer class.

**Example: `Calculator` with `static` members**

```java
package myproject.app;

class Calculator {
    // Static field (constant) - shared by all Calculator-related operations
    public static final double PI = 3.14159; // 'final' means its value cannot be changed

    // Static method - doesn't need a Calculator object to be called
    public static int add(int a, int b) {
        return a + b;
    }

    public static int subtract(int a, int b) {
        return a - b;
    }

    // Static block - executed once when the Calculator class is loaded
    static {
        System.out.println("Calculator class loaded. Static block executed.");
        // You could perform complex static initialization here
    }

    // Instance method (non-static) - requires an object
    public void printWelcome() {
        System.out.println("Welcome to the Calculator instance.");
        // Can access static members
        System.out.println("Value of PI: " + PI);
    }
}

public class Practice {
    public static void main(String[] args) {
        // Accessing static fields and methods directly using the class name
        System.out.println("PI value: " + Calculator.PI); // Output: 3.14159
        System.out.println("Sum: " + Calculator.add(10, 5));     // Output: 15
        System.out.println("Difference: " + Calculator.subtract(10, 5)); // Output: 5

        // Creating an object to call an instance method
        Calculator myCalc = new Calculator();
        myCalc.printWelcome(); // Output: Welcome to the Calculator instance.
                               //         Value of PI: 3.14159
    }
}
```
*(You'll notice "Calculator class loaded. Static block executed." appears before any other output because the `static` block runs when the class is first used/loaded.)*

---

## 9. Abstraction

**Abstraction** is the OOPs principle of **hiding complex implementation details** and showing only the essential features or functionalities to the user. It focuses on "what" an object does rather than "how" it does it.

Think of driving a car: you know how to use the steering wheel, pedals, and gears (the essential features), but you don't need to know the intricate details of how the engine, transmission, and braking system work internally.

**How Abstraction is Achieved in Java:**

Abstraction is primarily achieved in Java using:

1.  **Abstract Classes**
2.  **Interfaces**

### Abstract Classes

An **abstract class** is a class that cannot be instantiated (you cannot create objects directly from it). It can have both **abstract methods** (methods without a body, declared with the `abstract` keyword) and **concrete methods** (regular methods with a body).

* **`abstract` keyword:** Used to declare a class as abstract (`public abstract class ClassName {}`) or a method as abstract (`public abstract void methodName();`).
* **Purpose:** To define a common interface and some shared functionality for a group of related subclasses, while forcing those subclasses to provide specific implementations for the abstract methods.
* **Rules:**
    * An abstract class must be declared with an `abstract` keyword.
    * It can have abstract methods (without body) and concrete methods (with body).
    * It cannot be instantiated (you cannot do `new AbstractClass()`).
    * If a class has an abstract method, it must be an abstract class.
    * A concrete subclass extending an abstract class **must implement all inherited abstract methods**, or it must also be declared abstract.

**Example: `Shape` Abstract Class**

```java
package myproject.app;

// Abstract class
abstract class Shape {
    String color;

    public Shape(String color) {
        this.color = color;
    }

    // Concrete method (has a body)
    public void displayColor() {
        System.out.println("This shape is " + color);
    }

    // Abstract method (no body) - must be implemented by concrete subclasses
    public abstract double calculateArea(); // No implementation here
    public abstract void draw();          // No implementation here
}

// Concrete subclass implementing Shape
class Circle extends Shape {
    double radius;

    public Circle(String color, double radius) {
        super(color); // Call superclass constructor
        this.radius = radius;
    }

    @Override
    public double calculateArea() {
        return Math.PI * radius * radius;
    }

    @Override
    public void draw() {
        System.out.println("Drawing a " + color + " circle with radius " + radius);
    }
}

// Another concrete subclass implementing Shape
class Rectangle extends Shape {
    double length;
    double width;

    public Rectangle(String color, double length, double width) {
        super(color);
        this.length = length;
        this.width = width;
    }

    @Override
    public double calculateArea() {
        return length * width;
    }

    @Override
    public void draw() {
        System.out.println("Drawing a " + color + " rectangle with length " + length + " and width " + width);
    }
}

public class Practice {
    public static void main(String[] args) {
        // You cannot instantiate an abstract class directly:
        // Shape myShape = new Shape("Red"); // Compilation ERROR!

        // But you can create objects of concrete subclasses
        Shape circle = new Circle("Blue", 5.0);
        Shape rectangle = new Rectangle("Green", 4.0, 6.0);

        // Call methods on the objects
        circle.displayColor();    // Output: This shape is Blue
        circle.draw();            // Output: Drawing a Blue circle with radius 5.0
        System.out.println("Circle Area: " + circle.calculateArea()); // Output: Circle Area: 78.539...

        System.out.println("---");

        rectangle.displayColor(); // Output: This shape is Green
        rectangle.draw();         // Output: Drawing a Green rectangle with length 4.0 and width 6.0
        System.out.println("Rectangle Area: " + rectangle.calculateArea()); // Output: Rectangle Area: 24.0
    }
}
```

### Interfaces

An **interface** is a blueprint of a class. It defines a contract: any class that `implements` an interface must provide implementations for all the abstract methods declared in that interface.

* **`interface` keyword:** Used to declare an interface (`public interface InterfaceName {}`).
* **`implements` keyword:** Used by a class to implement an interface (`class MyClass implements MyInterface {}`).
* **Achieves "pure abstraction":** Before Java 8, interfaces could only contain abstract methods and constants (`public static final`). Since Java 8, they can also have `default` and `static` methods with implementations.
* **Supports multiple inheritance of "type" (or behavior):** A class can `implement` multiple interfaces (whereas it can only `extend` one class).

**Example: `Drawable` Interface**

```java
package myproject.app;

// Interface
interface Drawable {
    // All methods in an interface are implicitly public and abstract (before Java 8)
    // Since Java 8, you can have default and static methods with implementation.
    void draw();
    void resize(int percentage);

    // Default method (since Java 8) - provides a default implementation
    default void printInstructions() {
        System.out.println("Draw method implements basic drawing logic.");
    }
}

// Class implementing the Drawable interface
class Square implements Drawable {
    int side;

    public Square(int side) {
        this.side = side;
    }

    @Override
    public void draw() {
        System.out.println("Drawing a square with side " + side);
    }

    @Override
    public void resize(int percentage) {
        this.side = (int) (this.side * (1 + percentage / 100.0));
        System.out.println("Square resized to side " + side);
    }
}

// Another class implementing the Drawable interface
class Triangle implements Drawable {
    String type;

    public Triangle(String type) {
        this.type = type;
    }

    @Override
    public void draw() {
        System.out.println("Drawing a " + type + " triangle.");
    }

    @Override
    public void resize(int percentage) {
        System.out.println("Triangle resizing not yet implemented for " + percentage + "%");
    }
}

public class Practice {
    public static void main(String[] args) {
        Square sq = new Square(10);
        sq.draw();             // Output: Drawing a square with side 10
        sq.resize(20);         // Output: Square resized to side 12
        sq.printInstructions(); // Output: Draw method implements basic drawing logic.

        System.out.println("---");

        Triangle tri = new Triangle("equilateral");
        tri.draw();            // Output: Drawing a equilateral triangle.
        tri.resize(50);        // Output: Triangle resizing not yet implemented for 50%
        tri.printInstructions(); // Output: Draw method implements basic drawing logic.
    }
}
```

---

## 10. Polymorphism

**Polymorphism** means "many forms." In OOPs, it refers to the ability of an object to take on many forms, or the ability of a method to behave differently based on the object on which it is called.

Polymorphism allows you to treat objects of different classes in a uniform way, as long as they share a common base type (either a superclass or an interface).

Polymorphism in Java is achieved in two main ways:

### 1. Compile-time Polymorphism (Method Overloading)

* **Definition:** Occurs when there are multiple methods in the same class with the **same name but different parameter lists** (number of parameters, type of parameters, or order of parameters). The compiler decides which method to call at compile time based on the arguments provided.
* Also known as **Static Polymorphism** or **Early Binding**.

**Example: Method Overloading**

```java
package myproject.app;

class Calculator {
    // Method 1: adds two integers
    public int add(int a, int b) {
        return a + b;
    }

    // Method 2: adds three integers (different number of parameters)
    public int add(int a, int b, int c) {
        return a + b + c;
    }

    // Method 3: adds two doubles (different types of parameters)
    public double add(double a, double b) {
        return a + b;
    }
}

public class Practice {
    public static void main(String[] args) {
        Calculator calc = new Calculator();

        System.out.println("Sum of two ints: " + calc.add(10, 20));      // Calls Method 1
        System.out.println("Sum of three ints: " + calc.add(10, 20, 30)); // Calls Method 2
        System.out.println("Sum of two doubles: " + calc.add(10.5, 20.3)); // Calls Method 3
    }
}
```

### 2. Runtime Polymorphism (Method Overriding)

* **Definition:** Occurs when a subclass provides a specific implementation for a method that is already defined in its superclass. The decision of which method to call is made at runtime based on the actual type of the object, not the reference type.
* Also known as **Dynamic Polymorphism** or **Late Binding**.
* Requires an "is-a" relationship (inheritance).
* The method signature (name and parameters) must be the same in both superclass and subclass.
* The `@Override` annotation is optional but highly recommended to indicate that a method is intended to override a superclass method.

**Example: Method Overriding (using `Animal` base class)**

```java
package myproject.app;

// Superclass
class Animal {
    public void makeSound() {
        System.out.println("Animal makes a sound.");
    }
}

// Subclass 1
class Dog extends Animal {
    @Override // Overrides the makeSound method of Animal
    public void makeSound() {
        System.out.println("Dog barks: Woof! Woof!");
    }
}

// Subclass 2
class Cat extends Animal {
    @Override // Overrides the makeSound method of Animal
    public void makeSound() {
        System.out.println("Cat meows: Meow!");
    }

    public void scratch() {
        System.out.println("Cat scratches.");
    }
}

public class Practice {
    public static void main(String[] args) {
        // 1. Reference and Object are of the same type
        Dog myDog = new Dog();
        myDog.makeSound(); // Output: Dog barks: Woof! Woof!

        Cat myCat = new Cat();
        myCat.makeSound(); // Output: Cat meows: Meow!
        myCat.scratch();   // Output: Cat scratches.

        System.out.println("--- Runtime Polymorphism in action ---");

        // 2. Runtime Polymorphism (Upcasting)
        // Animal reference, but Dog object
        Animal animal1 = new Dog(); // Upcasting: A Dog IS-A Animal
        animal1.makeSound(); // Output: Dog barks: Woof! Woof! (Dog's method is called)
                             // The method to call is determined at runtime based on the *actual* object type (Dog).

        // Animal reference, but Cat object
        Animal animal2 = new Cat(); // Upcasting: A Cat IS-A Animal
        animal2.makeSound(); // Output: Cat meows: Meow! (Cat's method is called)

        // Using a loop to demonstrate polymorphism:
        Animal[] animals = new Animal[3];
        animals[0] = new Animal();
        animals[1] = new Dog();
        animals[2] = new Cat();

        for (Animal animal : animals) {
            animal.makeSound(); // Calls the specific makeSound() based on the actual object type
        }
        // Output:
        // Animal makes a sound.
        // Dog barks: Woof! Woof!
        // Cat meows: Meow!

        // animal2.scratch(); // ERROR! 'scratch()' is not defined in Animal, even if the object is a Cat.
                             // You can only call methods defined in the *reference* type (Animal),
                             // unless you downcast.
    }
}
```

This comprehensive explanation covers the core OOPs concepts in Java, ordered logically for a beginner, with practical examples for each. Mastering these concepts is key to writing robust, scalable, and maintainable Java applications.

---------------------------------------------------------------------------------------------------------------------------------------------------------------

When Overriding in java in it necessary to use the @Override ?

No, it is **not strictly necessary** to use the `@Override` annotation when overriding a method in Java. Your code will compile and run correctly without it, as long as the method you write genuinely overrides a method from a superclass or implements a method from an interface.

However, it is **highly recommended** to use `@Override` for several very good reasons:

### Why `@Override` is Highly Recommended:

1.  **Compiler Check (Error Prevention):**
    This is the primary and most important reason. When you use `@Override`, you are telling the Java compiler, "Hey, I intend for this method to override a method from my superclass or implement a method from an interface."
    * **If you make a mistake** (e.g., misspell the method name, use different parameters, or change the return type in a way that doesn't constitute a valid override), the compiler will immediately give you a **compilation error**.
    * **Without `@Override`**, if you make a mistake, the compiler will assume you're simply defining a *new method* in the subclass (method overloading, or just a new method altogether), not overriding. Your code would compile fine, but the method you *thought* you were overriding would never actually be called, leading to subtle and hard-to-find runtime bugs.

    **Example:**
    ```java
    class Animal {
        public void makeSound() {
            System.out.println("Animal makes a sound.");
        }
    }

    class Dog extends Animal {
        // Correct override
        @Override
        public void makeSound() {
            System.out.println("Dog barks.");
        }

        // --- What happens without @Override if you make a typo? ---
        // public void makesound() { // Typo: lowercase 's'
        //     System.out.println("Dog woofs.");
        // }
        // Without @Override, this would compile. But Animal's makeSound() would still be called
        // if you did Animal a = new Dog(); a.makeSound();

        // With @Override:
        // @Override
        // public void makesound() { // Typo: lowercase 's'
        //     System.out.println("Dog woofs.");
        // }
        // This would give a COMPILATION ERROR: "Method does not override method from its superclass"
        // This error guides you immediately to fix the typo.
    }
    ```

2.  **Readability and Clarity:**
    It makes your code easier to read and understand. When someone sees `@Override` above a method, they immediately know that this method is providing a specialized implementation for a method inherited from a parent class or interface.

3.  **Refactoring Safety:**
    If you or someone else later refactors the superclass (e.g., changes the name of the method you were overriding), the `@Override` annotation will cause a compilation error in your subclass. This prevents you from inadvertently breaking functionality by making the method no longer override its intended target.

### When to Use `@Override`:

* When you are overriding a method inherited from a **superclass**.
* When you are implementing a method defined in an **interface**.

### Conclusion:

While technically optional for the compiler to produce `.class` files, the `@Override` annotation is an invaluable tool for **ensuring correctness, improving readability, and enhancing the maintainability** of your Java code. It acts as a safety net, catching potential bugs at compile-time that would otherwise be difficult to diagnose at runtime. Always use it when you intend to override or implement a method.

---------------------------------------------------------------------------------------------------------------------------------------------------------

Why is Multiple inheritance not supported in Java?
Multiple inheritance refers to a scenario where a class can inherit features (fields and methods) from more than one superclass. While multiple inheritance can provide flexibility and reusability, it also introduces complexity and ambiguity, particularly in the context of method resolution.
Java does not support multiple inheritance with classes to avoid the **Diamond Problem** and other complexities. Here's a detailed explanation:
### The Diamond Problem
The **Diamond Problem** occurs when a class inherits from two classes that both inherit from a common superclass. This can lead to ambiguity in method resolution, as the compiler may not know which superclass's method to call.

Solution:
Java avoids this problem by not allowing a class to extend more than one class. Instead, Java uses interfaces to achieve a form of multiple inheritance without the associated issues.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------

Explain about toString method in Java and how we can override it to display our object properties when we print the object instead of a memory address .

The `toString()` method in Java is a powerful and frequently overridden method that plays a crucial role in how objects are represented as strings. Let's dive into its purpose, its default behavior, and how you can override it to display meaningful information about your objects.

---

## 1. What is the `toString()` Method?

The `toString()` method is a `public` method defined in the `java.lang.Object` class. Since `Object` is the superclass of all classes in Java, every class implicitly inherits a `toString()` method.

**Purpose:**
Its primary purpose is to **return a string representation of the object**. This string representation is intended to be a concise and informative description of the object.

---

## 2. Default Behavior of `toString()`

If you don't override `toString()` in your class, the default implementation from `java.lang.Object` is used. This default implementation returns a string that looks like this:

`className@hashCodeInHex`

* **`className`**: The fully qualified name of the class (e.g., `com.example.mypackage.MyClass`).
* **`@`**: A separator.
* **`hashCodeInHex`**: The unsigned hexadecimal representation of the object's hash code. The hash code is a unique (or nearly unique) integer generated by the JVM for each object.

**Example of Default Behavior:**

```java
class DefaultCar {
    String model;
    int year;

    public DefaultCar(String model, int year) {
        this.model = model;
        this.year = year;
    }
}

public class ToStringExample {
    public static void main(String[] args) {
        DefaultCar myCar = new DefaultCar("Mustang", 2023);

        // When you print an object directly, Java implicitly calls its toString() method.
        System.out.println(myCar);
        // Possible Output: DefaultCar@15db9742 (The hexadecimal hash code will vary)

        // It's the same as explicitly calling toString():
        System.out.println(myCar.toString());
        // Possible Output: DefaultCar@15db9742
    }
}
```
As you can see, the default output (`DefaultCar@15db9742`) is not very useful for understanding what *kind* of car `myCar` actually represents. It doesn't tell you the model or the year.

---

## 3. Why Override `toString()`?

The default `toString()` output is rarely useful for debugging or logging. By overriding `toString()`, you can provide a custom, human-readable string that includes the relevant **properties (fields)** of your object.

**Benefits of Overriding `toString()`:**

* **Debugging:** Easily inspect the state of an object during development by printing it.
* **Logging:** When an object is logged, its meaningful representation is automatically included.
* **Readability:** Makes your code and its output more understandable.
* **Testing:** Simplifies assertions in unit tests when checking object states.

---

## 4. How to Override `toString()`

To override the `toString()` method, you need to:

1.  Declare a method named `toString()`.
2.  It must have `public` access.
3.  It must have `String` as its return type.
4.  It must take no arguments.
5.  It's highly recommended to use the `@Override` annotation for compiler checks.

Inside the `toString()` method, you construct a `String` that combines the relevant fields of your object into a meaningful format.

**Example of Overriding `toString()` for a `Car` Object:**

```java
class Car {
    String model;
    int year;
    String color;

    public Car(String model, int year, String color) {
        this.model = model;
        this.year = year;
        this.color = color;
    }

    // Overriding the toString() method
    @Override // Recommended annotation
    public String toString() {
        // Construct a descriptive string using the object's properties
        return "Car [model=" + model + ", year=" + year + ", color=" + color + "]";
    }
}

public class ToStringExample {
    public static void main(String[] args) {
        Car myCar = new Car("Ford Mustang", 2024, "Red");
        Car anotherCar = new Car("Tesla Model 3", 2023, "Blue");

        // Now, when you print the Car object, it displays its properties
        System.out.println(myCar);     // Output: Car [model=Ford Mustang, year=2024, color=Red]
        System.out.println(anotherCar); // Output: Car [model=Tesla Model 3, year=2023, color=Blue]

        // This is implicitly calling toString():
        System.out.println("My favorite car is: " + myCar);

        // You can also explicitly call it:
        String carDetails = myCar.toString();
        System.out.println("Car details using explicit call: " + carDetails);
    }
}
```

### Best Practices for Overriding `toString()`:

* **Include all relevant fields:** Typically, you'll want to include all fields that define the object's state.
* **Consistent format:** While the format is up to you, a common convention is `ClassName [field1=value1, field2=value2, ...]`.
* **Concise:** Keep it informative but not overly verbose. Avoid including redundant information.
* **Avoid side effects:** `toString()` should only return a string representation and should not change the object's state.
* **Use `StringBuilder` or `String.format()` for complex strings:** For more complex `toString()` implementations with many fields, `StringBuilder` is more efficient than repeated `+` concatenation, or `String.format()` can be used for controlled formatting.

By overriding the `toString()` method, you gain much more control over how your Java objects are represented in string format, making your code easier to debug and understand.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Final Keyword in Java

The `final` keyword in Java is a non-access modifier that essentially means "cannot be changed" or "once assigned, always assigned." Its behavior varies slightly depending on whether it's applied to a variable, a method, or a class.

Let's explore each use case in detail.

---

## 1. `final` Variables

When `final` is applied to a variable, it means that the variable's value, once initialized, **cannot be reassigned**.

### 1.1. `final` with Primitive Types

If a `final` variable holds a primitive value (like `int`, `double`, `boolean`, `char`, etc.), its value becomes a constant after initialization.

**Example:**

```java
public class FinalVariableExample {
    public static void main(String[] args) {
        final int MAX_ATTEMPTS = 3; // Initialized at declaration

        // MAX_ATTEMPTS = 5; // COMPILE-TIME ERROR: cannot assign a value to final variable MAX_ATTEMPTS

        System.out.println("Maximum attempts allowed: " + MAX_ATTEMPTS);
    }
}
```

### 1.2. `final` with Reference Types (Objects)

This is a common point of confusion. When a `final` variable holds a reference to an object, it means:

* The **reference itself cannot be changed** to point to a different object.
* However, the **state (contents/fields) of the object** that the reference points to *can* be modified, if the object itself is mutable.

**Example:**

```java
import java.util.ArrayList;
import java.util.List;

public class FinalReferenceExample {
    public static void main(String[] args) {
        final List<String> immutableRefList = new ArrayList<>(); // Reference initialized

        // This is allowed: Modifying the contents of the object
        immutableRefList.add("Apple");
        immutableRefList.add("Banana");
        System.out.println("List contents after add: " + immutableRefList); // Output: [Apple, Banana]

        // This is NOT allowed: Reassigning the reference to a new object
        // immutableRefList = new ArrayList<>(); // COMPILE-TIME ERROR: cannot assign a value to final variable immutableRefList

        System.out.println("Final reference, but mutable object: " + immutableRefList);
    }
}
```
If you want the object itself to be immutable (its contents cannot change), you need to ensure the class of the object is designed to be immutable (e.g., `String`, `Integer`, or custom immutable classes).

### 1.3. Initialization of `final` Variables

A `final` variable must be initialized **exactly once**. This can happen in a few ways:

* **At the point of declaration:** (Most common for `static final` or local `final` variables).
    ```java
    final int value = 10;
    public static final double PI = 3.14159;
    ```
* **In the constructor (for instance `final` variables):** Each object instance can have its `final` variable initialized to a different value.
    ```java
    class MyClass {
        final int id; // Not initialized here

        public MyClass(int id) {
            this.id = id; // Initialized in the constructor
        }

        // public MyClass() { // COMPILE-TIME ERROR if this constructor exists and doesn't initialize id
        // }
    }
    ```
* **In a static initializer block (for `static final` variables):** For complex static final initializations.
    ```java
    class MyConfig {
        public static final String CONFIG_PATH;

        static {
            // Complex logic to determine config path
            CONFIG_PATH = System.getenv("APP_CONFIG_DIR") != null ? System.getenv("APP_CONFIG_DIR") : "/default/config";
        }
    }
    ```

### 1.4. Naming Convention for `final` Variables

* **Local `final` variables:** Typically use `camelCase` (e.g., `final int loopCount;`).
* **`static final` constants:** By convention, these are named in `UPPER_SNAKE_CASE` (e.g., `public static final int MAX_USERS = 100;`).

---

## 2. `final` Methods

When a method is declared `final`, it means that method **cannot be overridden** by any subclass.

**Example:**

```java
class Vehicle {
    public final void startEngine() { // This method cannot be overridden
        System.out.println("Engine started.");
    }

    public void stopEngine() {
        System.out.println("Engine stopped.");
    }
}

class Car extends Vehicle {
    // public void startEngine() { // COMPILE-TIME ERROR: cannot override final method from Vehicle
    //     System.out.println("Car engine started.");
    // }

    @Override // This is allowed, as stopEngine is not final
    public void stopEngine() {
        System.out.println("Car engine gracefully stopped.");
    }
}
```

**Why use `final` methods?**

* **Security:** To prevent subclasses from changing the core behavior of a method that is critical for the class's integrity or security. For example, methods in security-sensitive classes might be `final`.
* **Design Consistency:** To enforce a specific behavior that all subclasses must inherit without modification.
* **Performance (Minor):** In older Java versions, `final` methods could sometimes be inlined by the JVM, leading to minor performance gains. Modern JVMs are highly optimized and can perform such optimizations on non-final methods too, so this is rarely a primary reason anymore.

---

## 3. `final` Classes

When a class is declared `final`, it means that class **cannot be subclassed (extended)** by any other class.

**Example:**

```java
final class ImmutablePoint { // This class cannot be extended
    private final int x;
    private final int y;

    public ImmutablePoint(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public int getX() { return x; }
    public int getY() { return y; }

    // No setters, fields are final, making the object immutable
}

// class ColoredPoint extends ImmutablePoint { // COMPILE-TIME ERROR: cannot inherit from final class ImmutablePoint
//     String color;
//     public ColoredPoint(int x, int y, String color) {
//         super(x, y);
//         this.color = color;
//     }
// }
```

**Why use `final` classes?**

* **Immutability:** This is a very common reason. If a class is designed to be immutable (its objects' state cannot be changed after creation), making it `final` prevents malicious or accidental subclasses from breaking that immutability guarantee. Examples: `java.lang.String`, `java.lang.Integer`, `java.lang.Double`, etc., are all `final` classes.
* **Security:** Similar to `final` methods, `final` classes prevent unauthorized behavior modification through inheritance.
* **Design Stability:** When you want to ensure that a class's implementation cannot be altered or extended.
* **Performance (Minor):** The JVM can perform some optimizations on `final` classes, knowing that their methods will never be overridden.

------------------------------------------------------------------------------------------------------------------------------------------------------------------

Aggregation and Composition in Java

In object-oriented programming, **Aggregation** and **Composition** are two specific types of **Association** relationships between classes. Both represent a "has-a" relationship, meaning one object "has" or contains another object. The key difference lies in the **strength of the relationship** and the **lifecycles** of the contained objects.

---

## 1. Association (The General "Has-A" Relationship)

Before diving into Aggregation and Composition, let's briefly define **Association**.
An Association is a general term for a relationship between two separate classes where one class uses or is connected to another. It's a "has-a" relationship, but it doesn't specify how strong that "has-a" is.

**Example:** A `Student` is associated with a `Course`. A `Teacher` is associated with a `Subject`.

---

## 2. Aggregation (Weak "Has-A" Relationship)

**Definition:** Aggregation is a "has-a" relationship where the **contained object can exist independently** of the container object. It represents a "whole-part" relationship, but the part can exist without the whole. It's a **weak association**.

**Key Characteristics:**
* **Independent Lifecycles:** If the "whole" object is destroyed, the "part" object can continue to exist.
* **Weak Relationship:** The part can be shared by multiple whole objects (though this is not a strict rule, it's possible).
* **Represented by:** A field in one class that holds a reference to an object of another class, often passed in via a constructor or setter method.

**Analogy:** A `Department` has `Professor`s. If the `Department` ceases to exist, the `Professor`s don't necessarily disappear; they can still be `Professor`s and potentially join another department.

**Example in Java:**

```java
// Professor.java (The "Part" - can exist independently)
class Professor {
    String name;
    String subject;

    public Professor(String name, String subject) {
        this.name = name;
        this.subject = subject;
    }

    public void displayProfessorInfo() {
        System.out.println("Professor Name: " + name + ", Subject: " + subject);
    }
}

// Department.java (The "Whole" - aggregates Professors)
import java.util.ArrayList;
import java.util.List;

class Department {
    String departmentName;
    List<Professor> professors; // Department HAS-A list of Professors (Aggregation)

    public Department(String departmentName) {
        this.departmentName = departmentName;
        this.professors = new ArrayList<>(); // Initialize the list
    }

    // Method to add an existing Professor to the Department
    public void addProfessor(Professor prof) {
        this.professors.add(prof);
    }

    public void displayDepartmentInfo() {
        System.out.println("\nDepartment: " + departmentName);
        if (professors.isEmpty()) {
            System.out.println("  No professors in this department yet.");
        } else {
            System.out.println("  Professors:");
            for (Professor prof : professors) {
                prof.displayProfessorInfo();
            }
        }
    }
}

public class AggregationExample {
    public static void main(String[] args) {
        // Create Professor objects independently
        Professor prof1 = new Professor("Dr. Smith", "Physics");
        Professor prof2 = new Professor("Dr. Jones", "Chemistry");

        // Create a Department object
        Department physicsDept = new Department("Physics Department");

        // Add the professors to the department (Aggregation)
        physicsDept.addProfessor(prof1);
        physicsDept.addProfessor(prof2);

        physicsDept.displayDepartmentInfo();

        // Output:
        // Department: Physics Department
        //   Professors:
        //   Professor Name: Dr. Smith, Subject: Physics
        //   Professor Name: Dr. Jones, Subject: Chemistry

        // Demonstrate independent lifecycle:
        // If physicsDept goes out of scope or is destroyed, prof1 and prof2 still exist.
        System.out.println("\nProfessor Smith still exists outside the department context:");
        prof1.displayProfessorInfo(); // Output: Professor Name: Dr. Smith, Subject: Physics
    }
}
```

---

## 3. Composition (Strong "Has-A" Relationship)

**Definition:** Composition is a stronger form of "has-a" relationship where the **contained object cannot exist independently** of the container object. The "part" is an essential component of the "whole," and its existence is tied to the existence of the whole. It's a **strong association**.

**Key Characteristics:**
* **Dependent Lifecycles:** If the "whole" object is destroyed, the "part" object is also destroyed or ceases to exist meaningfully within that context.
* **Strong Relationship:** The part is usually created along with the whole and often isn't shared with other whole objects.
* **Represented by:** A field in one class that holds a reference to an object of another class, where the contained object is typically **created within the constructor** of the container class, or its lifecycle is explicitly managed by the container.

**Analogy:** A `House` has `Room`s. A `Room` cannot typically exist meaningfully without a `House` (if the house is demolished, the rooms inside it are also gone). An `Engine` is part of a `Car`. An `Engine` typically doesn't exist as a standalone entity once it's part of a `Car` and the `Car` is scrapped.

**Example in Java:**

```java
// Room.java (The "Part" - dependent on House)
class Room {
    String roomType;
    double area;

    public Room(String roomType, double area) {
        this.roomType = roomType;
        this.area = area;
        System.out.println("Creating " + roomType + " (Area: " + area + " sq ft)");
    }

    public void displayRoomInfo() {
        System.out.println("  - " + roomType + " (" + area + " sq ft)");
    }
}

// House.java (The "Whole" - composes Rooms)
import java.util.ArrayList;
import java.util.List;

class House {
    String address;
    List<Room> rooms; // House HAS-A list of Rooms (Composition)

    public House(String address) {
        this.address = address;
        this.rooms = new ArrayList<>();

        // Rooms are created as part of the House's construction (Composition)
        // They typically don't exist without being part of a House
        this.rooms.add(new Room("Living Room", 250.0));
        this.rooms.add(new Room("Bedroom", 180.0));
        this.rooms.add(new Room("Kitchen", 120.0));
        System.out.println("House at " + address + " is built with its rooms.");
    }

    public void displayHouseInfo() {
        System.out.println("\nHouse Address: " + address);
        System.out.println("Rooms in this house:");
        for (Room room : rooms) {
            room.displayRoomInfo();
        }
    }

    // A finalizer (for demonstration, not reliable in modern Java)
    // to show rooms "disappearing" when the house does.
    // In real-world, memory management handles this.
    @Override
    protected void finalize() throws Throwable {
        System.out.println("House at " + address + " is being destroyed. Its rooms are also gone.");
        super.finalize();
    }
}

public class CompositionExample {
    public static void main(String[] args) {
        System.out.println("Building a new house...");
        House myHouse = new House("123 Main St"); // Rooms are created here
        myHouse.displayHouseInfo();

        System.out.println("\nHouse goes out of scope (e.g., destroyed).");
        myHouse = null; // Object is now eligible for garbage collection

        // For demonstration of finalize (not guaranteed to run immediately)
        System.gc(); // Request garbage collection
        try {
            Thread.sleep(100); // Give GC a moment
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        // Output:
        // Building a new house...
        // Creating Living Room (Area: 250.0 sq ft)
        // Creating Bedroom (Area: 180.0 sq ft)
        // Creating Kitchen (Area: 120.0 sq ft)
        // House at 123 Main St is built with its rooms.
        //
        // House Address: 123 Main St
        // Rooms in this house:
        //   - Living Room (250.0 sq ft)
        //   - Bedroom (180.0 sq ft)
        //   - Kitchen (120.0 sq ft)
        //
        // House goes out of scope (e.g., destroyed).
        // House at 123 Main St is being destroyed. Its rooms are also gone. (This line might appear later or not at all depending on GC)
    }
}
```
In the `CompositionExample`, the `Room` objects are created *within* the `House` constructor. They are intrinsic parts of the `House`. If the `House` object is no longer referenced and becomes eligible for garbage collection, its `Room` objects typically also become eligible because their only references were from within that `House`.
---

## When to Use Which?

* **Use Aggregation** when:
    * The "part" can exist meaningfully on its own.
    * The "part" might be shared by multiple "whole" objects.
    * The relationship is more about usage than containment (e.g., a `Library` uses `Books`, but `Books` exist independently).

* **Use Composition** when:
    * The "part" is an integral and essential component of the "whole."
    * The "part" cannot exist meaningfully without the "whole."
    * The lifecycle of the "part" is directly managed by the "whole."
    * The "whole" is responsible for the creation and destruction of its "parts."

Choosing between aggregation and composition helps in designing robust, clear, and logically sound object-oriented systems.

-------------------------------------------------------------------------------------------------------------------------------------------------------------

Wrapper classes in Java

In Java, **Wrapper Classes** are a set of classes that convert primitive data types (like `int`, `char`, `boolean`, `double`) into objects. They "wrap" the primitive value inside an object.

## 1. What are Wrapper Classes?

Java is designed as an object-oriented programming language, where everything is ideally treated as an object. However, for performance reasons and simplicity, Java retains primitive data types.

Wrapper classes serve as a bridge between Java's primitive types and its object-oriented world. They provide an object representation for each primitive type.

## 2. Why Do We Need Wrapper Classes?

Wrapper classes are essential for several reasons:

1.  **Working with Collections Framework:**
    * Java's Collections Framework (e.g., `ArrayList`, `HashMap`, `HashSet`) can only store objects, not primitive types.
    * If you want to store a list of integers, you cannot use `ArrayList<int>`. You must use `ArrayList<Integer>`.

2.  **Generics:**
    * Generic types (like `List<T>`, `Map<K, V>`) require type parameters to be objects, not primitives.
    * You can declare `List<Double>` but not `List<double>`.

3.  **Nullability:**
    * Primitive types cannot be `null`. They always have a default value (e.g., `0` for `int`, `false` for `boolean`).
    * Wrapper class objects, however, can be `null`, which is useful when a value might be absent or undefined.

4.  **Utility Methods:**
    * Wrapper classes provide useful utility methods for converting primitive values to strings, strings to primitive values, and various base conversions (e.g., `Integer.parseInt()`, `Double.valueOf()`, `Integer.toHexString()`).

5.  **Serialization:**
    * Objects can be serialized (converted into a byte stream for storage or transmission), but primitives cannot directly. Wrapper classes enable serialization of primitive values.

## 3. List of Wrapper Classes

For each of Java's 8 primitive data types, there is a corresponding wrapper class in the `java.lang` package:

| Primitive Type | Wrapper Class |
| :------------- | :------------ |
| `byte`         | `Byte`        |
| `short`        | `Short`       |
| `int`          | `Integer`     |
| `long`         | `Long`        |
| `float`        | `Float`       |
| `double`       | `Double`      |
| `char`         | `Character`   |
| `boolean`      | `Boolean`     |

## 4. Autoboxing and Unboxing (Introduced in Java 5)

Before Java 5, converting between primitives and wrapper objects was a manual process, requiring explicit calls to methods like `new Integer(value)` for boxing and `intValue()` for unboxing.

**Autoboxing** and **Unboxing** are features introduced in Java 5 that automate this conversion process, making the code much cleaner and easier to read.

### a. Autoboxing

* **Definition:** The automatic conversion that the Java compiler makes from a primitive type to its corresponding wrapper class object.
* **When it happens:** Whenever a primitive value is expected to be an object.

```java
public class AutoboxingExample {
    public static void main(String[] args) {
        int primitiveInt = 100;
        Integer wrapperInt = primitiveInt; // Autoboxing: int to Integer object
        // Equivalent to: Integer wrapperInt = Integer.valueOf(primitiveInt); (Behind the scenes)

        double primitiveDouble = 25.5;
        Double wrapperDouble = primitiveDouble; // Autoboxing: double to Double object

        System.out.println("Wrapper Int: " + wrapperInt);
        System.out.println("Wrapper Double: " + wrapperDouble);

        // In collections:
        List<Integer> numbers = new ArrayList<>();
        numbers.add(50); // Autoboxing: 50 (int) is autoboxed to an Integer object
        System.out.println("List: " + numbers);
    }
}
```

### b. Unboxing

* **Definition:** The automatic conversion that the Java compiler makes from a wrapper class object to its corresponding primitive type.
* **When it happens:** Whenever a wrapper object is expected to be a primitive value.

```java
import java.util.ArrayList;
import java.util.List;

public class UnboxingExample {
    public static void main(String[] args) {
        Integer wrapperInt = 200;
        int primitiveInt = wrapperInt; // Unboxing: Integer object to int primitive
        // Equivalent to: int primitiveInt = wrapperInt.intValue(); (Behind the scenes)

        Double wrapperDouble = 75.0;
        double primitiveDouble = wrapperDouble; // Unboxing: Double object to double primitive

        System.out.println("Primitive Int: " + primitiveInt);
        System.out.println("Primitive Double: " + primitiveDouble);

        // In collections (when retrieving):
        List<Integer> numbers = new ArrayList<>();
        numbers.add(50);
        int firstNum = numbers.get(0); // Unboxing: Integer object from list is unboxed to int
        System.out.println("First number from list (unboxed): " + firstNum);
    }
}
```

### Potential Pitfalls of Autoboxing/Unboxing:

1.  **`NullPointerException`:** If a wrapper object is `null` and you try to unbox it, a `NullPointerException` will occur at runtime.
    ```java
    Integer nullInt = null;
    // int val = nullInt; // This line will compile, but throws NullPointerException at runtime
    ```
2.  **Performance Overhead:** While convenient, autoboxing/unboxing involves creating objects. In performance-critical applications or tight loops, excessive boxing/unboxing can lead to minor performance overhead and increased memory usage compared to working directly with primitives.
3.  **`==` Operator Behavior:** When comparing wrapper objects using `==`, it compares their *references* (whether they are the exact same object in memory) rather than their *values*. This can lead to unexpected results. For comparing values, always use `equals()` for wrapper classes (or unbox them first if you want primitive `==` behavior).
    ```java
    Integer a = 100; // Autoboxed
    Integer b = 100; // Autoboxed
    Integer c = 200; // Autoboxed
    Integer d = 200; // Autoboxed

    System.out.println(a == b); // Output: true (Java caches Integer objects for values -128 to 127)
    System.out.println(c == d); // Output: false (Values outside cache range create new objects)
    System.out.println(c.equals(d)); // Output: true (Always use .equals() for value comparison)
    ```

In summary, wrapper classes are vital in Java because they allow primitive values to participate in the object-oriented ecosystem, especially with the Collections Framework and Generics, while autoboxing and unboxing simplify the conversion process.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------

ArrayList in Java

The `ArrayList` is one of the most commonly used classes in the Java Collections Framework. It's a dynamic, resizable array implementation of the `List` interface, making it incredibly versatile for storing and managing sequences of elements.

---

## 1. What is `ArrayList`?

* **Resizable-array implementation of the `List` interface.** This means it behaves like a dynamic array. Unlike traditional arrays (e.g., `String[]`), an `ArrayList` can grow or shrink in size as elements are added or removed.
* **Ordered Collection:** Elements are stored in the order they are added, and this order is maintained.
* **Allows Duplicates:** You can store the same element multiple times.
* **Allows `null` elements:** You can add `null` as an element.
* **Based on an Array:** Internally, `ArrayList` uses a regular Java array to store its elements. When the internal array becomes full, `ArrayList` automatically creates a new, larger array (typically 1.5 times the original size), and copies all the elements from the old array to the new one. This is the "resizing" mechanism.

## 2. Key Characteristics and Advantages:

* **Dynamic Sizing:** Grows and shrinks automatically.
* **Fast Random Access:** Accessing an element by its index (`get(index)`) is very fast (O(1) time complexity) because it directly accesses an element in the underlying array.
* **Maintains Insertion Order:** The order in which elements are added is preserved.
* **Good for Retrieval Operations:** Excellent for scenarios where you frequently need to retrieve elements by index.

## 3. Disadvantages and When Not to Use:

* **Slower Insertions/Deletions in the Middle:** If you insert or delete an element in the middle of an `ArrayList`, all subsequent elements have to be shifted. This can be a costly operation (O(n) time complexity), especially for large lists.
* **Not Synchronized (Not Thread-Safe):** `ArrayList` is not thread-safe. If multiple threads access and modify an `ArrayList` concurrently, you might get inconsistent results. For thread-safe operations, consider `java.util.Collections.synchronizedList()` or `java.util.concurrent.CopyOnWriteArrayList`.
* **Memory Overhead:** Due to its resizing mechanism, `ArrayList` might allocate more memory than immediately needed, leading to some wasted space.

---

## 4. How to Initialize `ArrayList`

You typically use the `ArrayList` class and the `List` interface together for good programming practice (program to interfaces).

```java
import java.util.ArrayList;
import java.util.List;

public class ArrayListInitialization {
    public static void main(String[] args) {
        // 1. Default constructor: Creates an empty ArrayList with a default initial capacity (usually 10).
        List<String> names1 = new ArrayList<>();

        // 2. Constructor with initial capacity: Creates an ArrayList with a specified initial capacity.
        // Useful if you have an idea of how many elements you'll add to avoid frequent re-sizing.
        List<Integer> numbers = new ArrayList<>(50); // Capacity for 50 elements

        // 3. Constructor with a Collection: Creates an ArrayList containing all elements of another collection.
        List<String> initialNames = new ArrayList<>();
        initialNames.add("Alice");
        initialNames.add("Bob");
        List<String> names2 = new ArrayList<>(initialNames);

        System.out.println("Names1 (empty): " + names1);
        System.out.println("Names2 (from collection): " + names2);
    }
}
```

---

## 5. Commonly Used `ArrayList` Methods

Here's a list of some of the most frequently used methods of `ArrayList`, along with examples.

**Methods inherited from `List` interface (and `Collection`, `Iterable`):**

1.  `add(E e)`: Appends the specified element to the end of this list.
2.  `add(int index, E element)`: Inserts the specified element at the specified position in this list. Shifts the element currently at that position (if any) and any subsequent elements to the right.
3.  `get(int index)`: Returns the element at the specified position in this list.
4.  `set(int index, E element)`: Replaces the element at the specified position in this list with the specified element. Returns the element previously at the specified position.
5.  `remove(int index)`: Removes the element at the specified position in this list. Shifts any subsequent elements to the left. Returns the element that was removed.
6.  `remove(Object o)`: Removes the first occurrence of the specified element from this list, if it is present. Returns `true` if this list contained the specified element.
7.  `size()`: Returns the number of elements in this list.
8.  `isEmpty()`: Returns `true` if this list contains no elements.
9.  `contains(Object o)`: Returns `true` if this list contains the specified element.
10. `indexOf(Object o)`: Returns the index of the first occurrence of the specified element in this list, or -1 if this list does not contain the element.
11. `lastIndexOf(Object o)`: Returns the index of the last occurrence of the specified element in this list, or -1 if this list does not contain the element.
12. `clear()`: Removes all of the elements from this list. The list will be empty after this call returns.
13. `toArray()`: Returns an array containing all of the elements in this list in proper sequence (from first to last element).
14. `toArray(T[] a)`: Returns an array containing all of the elements in this list in proper sequence; the runtime type of the returned array is that of the specified array.
15. `addAll(Collection<? extends E> c)`: Appends all of the elements in the specified collection to the end of this list, in the order that they are returned by the specified collection's iterator.
16. `addAll(int index, Collection<? extends E> c)`: Inserts all of the elements in the specified collection into this list at the specified position.
17. `removeAll(Collection<?> c)`: Removes from this list all of its elements that are also contained in the specified collection.
18. `retainAll(Collection<?> c)`: Retains only the elements in this list that are contained in the specified collection. In other words, removes all elements from this list that are not contained in the specified collection.
19. `iterator()`: Returns an iterator over the elements in this list in proper sequence.
20. `listIterator()`: Returns a list iterator over the elements in this list (in proper sequence).
21. `subList(int fromIndex, int toIndex)`: Returns a view of the portion of this list between the specified `fromIndex`, inclusive, and `toIndex`, exclusive.
22. `forEach(Consumer<? super E> action)` (Java 8+): Performs the given action for each element of the `Iterable` until all elements have been processed or the action throws an exception.

### Example Demonstrating Multiple Methods:

```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;

public class ArrayListMethodsDemo {
    public static void main(String[] args) {
        List<String> fruits = new ArrayList<>();

        // 1. add(E e)
        fruits.add("Apple");
        fruits.add("Banana");
        fruits.add("Cherry");
        fruits.add("Date");
        fruits.add("Banana"); // Duplicates are allowed
        System.out.println("Initial list: " + fruits); // [Apple, Banana, Cherry, Date, Banana]

        // 2. size()
        System.out.println("Size of list: " + fruits.size()); // 5

        // 3. get(int index)
        System.out.println("Element at index 2: " + fruits.get(2)); // Cherry

        // 4. add(int index, E element)
        fruits.add(1, "Grape"); // Insert at index 1
        System.out.println("After adding Grape at index 1: " + fruits); // [Apple, Grape, Banana, Cherry, Date, Banana]

        // 5. set(int index, E element)
        fruits.set(0, "Apricot"); // Replace element at index 0
        System.out.println("After setting index 0 to Apricot: " + fruits); // [Apricot, Grape, Banana, Cherry, Date, Banana]

        // 6. remove(Object o)
        fruits.remove("Banana"); // Removes the first "Banana"
        System.out.println("After removing first Banana: " + fruits); // [Apricot, Grape, Cherry, Date, Banana]

        // 7. remove(int index)
        String removedFruit = fruits.remove(3); // Removes element at index 3 ("Date")
        System.out.println("Removed fruit: " + removedFruit); // Date
        System.out.println("After removing index 3: " + fruits); // [Apricot, Grape, Cherry, Banana]

        // 8. contains(Object o)
        System.out.println("Does list contain Cherry? " + fruits.contains("Cherry")); // true
        System.out.println("Does list contain Mango? " + fruits.contains("Mango"));   // false

        // 9. indexOf(Object o) & lastIndexOf(Object o)
        fruits.add("Grape"); // Add another Grape
        System.out.println("List with multiple Grapes: " + fruits); // [Apricot, Grape, Cherry, Banana, Grape]
        System.out.println("First index of Grape: " + fruits.indexOf("Grape"));   // 1
        System.out.println("Last index of Grape: " + fruits.lastIndexOf("Grape")); // 4

        // 10. isEmpty()
        System.out.println("Is list empty? " + fruits.isEmpty()); // false

        // 11. addAll(Collection<? extends E> c)
        List<String> berries = new ArrayList<>(Arrays.asList("Strawberry", "Blueberry"));
        fruits.addAll(berries);
        System.out.println("After adding berries: " + fruits); // [Apricot, Grape, Cherry, Banana, Grape, Strawberry, Blueberry]

        // 12. removeAll(Collection<?> c)
        fruits.removeAll(Arrays.asList("Grape", "Banana"));
        System.out.println("After removing Grapes and Bananas: " + fruits); // [Apricot, Cherry, Strawberry, Blueberry]

        // 13. retainAll(Collection<?> c)
        List<String> keptFruits = new ArrayList<>(Arrays.asList("Apricot", "Blueberry", "Pineapple"));
        fruits.retainAll(keptFruits); // Retain only Apricot and Blueberry that are in 'fruits'
        System.out.println("After retaining Apricot and Blueberry: " + fruits); // [Apricot, Blueberry]

        // 14. forEach (Java 8+)
        System.out.print("Using forEach: ");
        fruits.forEach(fruit -> System.out.print(fruit + " ")); // Apricot Blueberry
        System.out.println();

        // 15. clear()
        fruits.clear();
        System.out.println("After clear: " + fruits); // []
        System.out.println("Is list empty after clear? " + fruits.isEmpty()); // true
    }
}
```

`ArrayList` is a fundamental building block in Java programming for scenarios where you need a dynamic, ordered collection with fast random access.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------

Exception Handling in Java

Exception handling in Java is a robust mechanism to manage errors or unexpected events that occur during the execution of a program. It allows your application to deal with these situations gracefully, preventing abrupt termination and making your code more resilient and reliable.

---

## 1. What is an Exception?

An **exception** is an event, which occurs during the execution of a program, that disrupts the normal flow of the program's instructions. When an exceptional event occurs, the program's normal execution is halted, and the Java Virtual Machine (JVM) creates an **exception object**. If this object is not handled, the program will terminate abruptly.

Think of it like this: You're following a recipe (your program's instructions). Suddenly, you realize you're missing an ingredient (an exception occurs). If you don't have a plan (exception handling) for what to do when an ingredient is missing, you can't finish the recipe (your program crashes). But if your plan says, "If Ingredient X is missing, substitute it with Ingredient Y, or go to the store" (exception handling), then you can continue.

## 2. Why Exception Handling?

* **Graceful Termination:** Prevents programs from crashing suddenly, providing a user-friendly experience (e.g., displaying an error message instead of a cryptic stack trace).
* **Separation of Concerns:** Allows you to separate the code that performs the normal business logic from the code that handles error conditions.
* **Robustness:** Makes your application more reliable and less prone to breaking under unexpected circumstances (e.g., network down, file not found, invalid user input).
* **Logging & Debugging:** Provides structured ways to log error details, which is invaluable for debugging and maintenance.

---

## 3. The Exception Hierarchy

All exceptions and errors in Java are subclasses of the `java.lang.Throwable` class.

```
Throwable
  ‚îú‚îÄ‚îÄ Error (Unchecked)
  ‚îî‚îÄ‚îÄ Exception (Checked & Unchecked)
        ‚îú‚îÄ‚îÄ IOException (Checked)
        ‚îú‚îÄ‚îÄ SQLException (Checked)
        ‚îú‚îÄ‚îÄ RuntimeException (Unchecked)
        ‚îÇ     ‚îú‚îÄ‚îÄ NullPointerException
        ‚îÇ     ‚îú‚îÄ‚îÄ ArrayIndexOutOfBoundsException
        ‚îÇ     ‚îî‚îÄ‚îÄ ArithmeticException
        ‚îî‚îÄ‚îÄ ... other Exceptions
```

### a. `Error`

* `Error`s represent **serious problems** that an application should **not try to catch**.
* They typically indicate unrecoverable conditions in the JVM itself or the environment (e.g., hardware issues, memory corruption).
* Examples: `OutOfMemoryError`, `StackOverflowError`, `VirtualMachineError`.
* You generally don't handle `Error`s in your application code; they are often indicative of a fundamental system problem.

### b. `Exception`

`Exception`s represent conditions that an application **might want to catch and handle**. They are further divided into two categories:

#### i. Checked Exceptions

* These are exceptions that the Java compiler **forces you to handle or declare**.
* If a method might throw a checked exception, you **must** either:
    1.  **Catch it** using a `try-catch` block.
    2.  **Declare it** in the method signature using the `throws` keyword, passing the responsibility to the calling method.
* They typically represent situations that are beyond the program's immediate control but are predictable and recoverable (e.g., file not found, network connection issues, database problems).
* Examples: `IOException`, `SQLException`, `FileNotFoundException`, `ClassNotFoundException`.

#### ii. Unchecked Exceptions (`RuntimeException` and its subclasses)

* These are exceptions that the Java compiler **does not force you to handle or declare**.
* They typically indicate **programming errors** or logical flaws in your code (e.g., trying to access an array element out of bounds, dividing by zero, dereferencing a `null` object).
* While you *can* catch them, the general advice is to **fix the underlying bug** rather than relying on exception handling.
* Examples: `NullPointerException`, `ArrayIndexOutOfBoundsException`, `ArithmeticException`, `IllegalArgumentException`.

---

## 4. Keywords for Exception Handling

Java provides five keywords for handling exceptions:

1.  **`try`**:
    * The `try` block contains the code that might throw an exception.
    * It must be followed by at least one `catch` block or a `finally` block (or both).

2.  **`catch`**:
    * The `catch` block is used to catch and handle a specific type of exception.
    * It specifies the type of exception it can handle in parentheses (e.g., `catch (IOException e)`).
    * You can have multiple `catch` blocks for different types of exceptions.

3.  **`finally`**:
    * The `finally` block contains code that will **always execute**, regardless of whether an exception occurred in the `try` block or was caught by a `catch` block.
    * It's primarily used for **resource cleanup** (e.g., closing file streams, database connections, network sockets) to ensure resources are released even if an error occurs.

4.  **`throw`**:
    * The `throw` keyword is used to **explicitly throw an exception object** from your code.
    * You can throw both built-in exceptions or custom (user-defined) exceptions.

5.  **`throws`**:
    * The `throws` keyword is used in a **method signature** to declare that the method might throw one or more specified **checked exceptions**.
    * It informs the caller of the method that they need to handle these exceptions.

---

## 5. Detailed Explanation of `try-catch-finally` Block

This is the core structure for handling exceptions.

```java
public class TryCatchFinallyExample {

    public static void main(String[] args) {
        // Example 1: Basic try-catch for a common RuntimeException
        System.out.println("--- Example 1: Basic ArithmeticException ---");
        try {
            int result = 10 / 0; // This will throw an ArithmeticException
            System.out.println("Result: " + result); // This line will not be executed
        } catch (ArithmeticException e) {
            System.err.println("Error: Division by zero is not allowed.");
            System.err.println("Exception details: " + e.getMessage()); // Prints the error message
            e.printStackTrace(); // Prints the stack trace for debugging
        } finally {
            System.out.println("Finally block always executes.");
        }
        System.out.println("Program continues after handling.");


        // Example 2: Multiple catch blocks
        System.out.println("\n--- Example 2: Multiple Catch Blocks ---");
        String[] names = {"Alice", "Bob"};
        try {
            String name = names[2]; // ArrayIndexOutOfBoundsException
            System.out.println(name.length()); // NullPointerException (if name was null)
        } catch (ArrayIndexOutOfBoundsException e) {
            System.err.println("Error: Array index out of bounds!");
        } catch (NullPointerException e) { // Less specific catch blocks should be after more specific ones
            System.err.println("Error: Tried to access a null object!");
        } catch (Exception e) { // Catch-all for any other Exception (should be last)
            System.err.println("An unexpected error occurred: " + e.getMessage());
        } finally {
            System.out.println("Cleanup complete for Example 2.");
        }

        // Example 3: Catching multiple exceptions in one block (Java 7+)
        System.out.println("\n--- Example 3: Multi-catch (Java 7+) ---");
        try {
            // Simulate either exception
            if (Math.random() > 0.5) {
                int[] arr = new int[5];
                System.out.println(arr[10]); // ArrayIndexOutOfBoundsException
            } else {
                String text = null;
                System.out.println(text.length()); // NullPointerException
            }
        } catch (ArrayIndexOutOfBoundsException | NullPointerException e) {
            System.err.println("Caught a specific runtime error: " + e.getClass().getSimpleName());
            // You can also use methods common to both exception types here
            System.err.println("Error message: " + e.getMessage());
        }

        // Example 4: finally block with return statement
        System.out.println("\n--- Example 4: Finally with Return ---");
        System.out.println("Value from method: " + demonstrateFinallyWithReturn());
    }

    public static int demonstrateFinallyWithReturn() {
        try {
            System.out.println("Inside try block.");
            return 10; // This return statement is executed
        } catch (Exception e) {
            System.err.println("Inside catch block.");
            return 20;
        } finally {
            System.out.println("Inside finally block. This always executes AFTER the try/catch but BEFORE return.");
            // If you put a return here, it would override the try/catch's return
            // return 30; // Uncommenting this would make the method always return 30
        }
    }
}
```

**Important Notes on `try-catch-finally`:**

* **Order of `catch` blocks:** Always place more specific `catch` blocks before more general ones. If `catch (Exception e)` comes first, it will catch all exceptions, and subsequent specific `catch` blocks will be unreachable (compiler error).
* **`finally` execution:** The `finally` block will execute even if:
    * An exception is thrown but not caught.
    * A `return`, `break`, or `continue` statement is executed within the `try` or `catch` block.
    * There's an unhandled exception (it executes before the program terminates).

---

## 6. `throw` Keyword (Throwing an Exception)

`throw` is used to explicitly throw an instance of `Throwable` (an `Exception` or `Error`).

```java
public class ThrowExample {
    public static void validateAge(int age) {
        if (age < 18) {
            // Explicitly throw an IllegalArgumentException
            throw new IllegalArgumentException("Age cannot be less than 18.");
        } else {
            System.out.println("Age is valid.");
        }
    }

    public static void main(String[] args) {
        try {
            validateAge(15); // This will throw an exception
        } catch (IllegalArgumentException e) {
            System.err.println("Validation Error: " + e.getMessage());
        }

        validateAge(20); // This will execute successfully
    }
}
```

## 7. `throws` Keyword (Declaring an Exception)

`throws` is used in a method signature to indicate that a method *might* throw one or more **checked exceptions**. It delegates the responsibility of handling that exception to the caller of the method.

```java
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;

public class ThrowsExample {

    // This method declares that it might throw FileNotFoundException and IOException
    public static void readFile(String filePath) throws FileNotFoundException, IOException {
        FileReader reader = null;
        try {
            reader = new FileReader(filePath);
            System.out.println("File opened successfully.");
            int charCode;
            while ((charCode = reader.read()) != -1) {
                System.out.print((char) charCode);
            }
            System.out.println("\nFile read successfully.");
        } finally {
            if (reader != null) {
                reader.close(); // This close() method also throws IOException, so it's in the throws clause
            }
        }
    }

    public static void main(String[] args) {
        try {
            readFile("nonexistent_file.txt");
        } catch (FileNotFoundException e) {
            System.err.println("Error: File not found at the specified path.");
        } catch (IOException e) {
            System.err.println("Error during file reading/closing: " + e.getMessage());
        }
        System.out.println("Program finished.");
    }
}
```

## 8. Custom/User-Defined Exceptions

You can create your own exception classes by extending `Exception` (for checked exceptions) or `RuntimeException` (for unchecked exceptions). This is useful for:

* Providing more specific error information.
* Creating a clear separation of business logic errors.

```java
// Custom Checked Exception
class InsufficientFundsException extends Exception {
    public InsufficientFundsException(String message) {
        super(message);
    }
}

class BankAccount {
    private double balance;

    public BankAccount(double initialBalance) {
        this.balance = initialBalance;
    }

    public void withdraw(double amount) throws InsufficientFundsException {
        if (amount > balance) {
            throw new InsufficientFundsException("Attempted to withdraw " + amount + " but only " + balance + " available.");
        }
        balance -= amount;
        System.out.println("Withdrawal successful. New balance: " + balance);
    }

    public double getBalance() {
        return balance;
    }
}

public class CustomExceptionExample {
    public static void main(String[] args) {
        BankAccount account = new BankAccount(500);
        try {
            account.withdraw(600); // This will throw InsufficientFundsException
        } catch (InsufficientFundsException e) {
            System.err.println("Transaction failed: " + e.getMessage());
        }
        System.out.println("Current balance: " + account.getBalance()); // Output: Current balance: 500.0
    }
}
```

---

## 9. Best Practices in Exception Handling

1.  **Be Specific in `catch` Blocks:** Catch specific exceptions rather than general `Exception` or `Throwable`. This allows you to handle different error types appropriately.
2.  **Don't Swallow Exceptions:** Never just catch an exception and do nothing (`catch (Exception e) {}`). If you catch it, at least log it or throw a more specific exception. Silently ignoring exceptions can lead to hard-to-debug issues.
3.  **Log Exceptions:** Always log the full stack trace of an exception (`e.printStackTrace()` for quick debugging, but a proper logging framework like Log4j or SLF4j for production).
4.  **Throw Early, Catch Late:** Throw an exception as soon as an error condition is detected. Catch it only at a point where you can meaningfully handle it (e.g., display an error to the user, retry an operation). Don't catch an exception just to re-throw it without adding value.
5.  **Clean Up Resources (Always!):** Use `finally` blocks or, even better, **Try-with-Resources** (Java 7+) to ensure that resources like file streams, network connections, and database connections are always closed, preventing resource leaks.

    ```java
    // Try-with-Resources (Preferred for auto-closable resources)
    import java.io.BufferedReader;
    import java.io.FileReader;
    import java.io.IOException;

    public class TryWithResourcesExample {
        public static void main(String[] args) {
            String line;
            try (BufferedReader br = new BufferedReader(new FileReader("example.txt"))) {
                // br is automatically closed when the try block exits, regardless of exceptions
                while ((line = br.readLine()) != null) {
                    System.out.println(line);
                }
            } catch (IOException e) {
                System.err.println("An I/O error occurred: " + e.getMessage());
            }
        }
    }
    ```
6.  **Avoid Catching `Error` or `RuntimeException`:** Unless you have a very specific reason and a robust recovery strategy, avoid catching `Error` (which indicates serious JVM issues) or the generic `RuntimeException` (which typically indicates a bug that should be fixed).

By following these principles, you can write Java applications that are robust, maintainable, and gracefully handle unexpected situations.

------------------------------------------------------------------------------------------------------------------------------------------------------------

Try with Resources and how is it better than normal try-catch-finally

`try-with-resources` is a statement introduced in **Java 7** that simplifies and improves resource management in Java. It ensures that critical resources (like file streams, database connections, network sockets, etc.) are automatically closed after the `try` block's execution, regardless of whether the `try` block completes normally or an exception occurs.

## 1. What is `try-with-resources`?

The `try-with-resources` statement works with any object that implements the `java.lang.AutoCloseable` interface (which `java.io.Closeable` extends). Most of Java's I/O and database resources implement this interface.

**Syntax:**

```java
try (ResourceClass resource1 = new ResourceClass();
     ResourceClass2 resource2 = new ResourceClass2()) { // You can declare multiple resources
    // Code that uses resource1 and resource2
    // ... potentially throws exceptions
} catch (SomeException e) {
    // Handle exceptions
} finally {
    // Optional: Code that *always* executes, but closing resources is handled by try-with-resources
}
```

The resources declared within the parentheses of the `try` statement are implicitly declared as `final` and are automatically closed when the `try` block finishes, in reverse order of their declaration.

## 2. The Problem `try-with-resources` Solves (The "Normal Try Block" Problem)

Before `try-with-resources`, properly closing resources typically required a verbose `try-catch-finally` block, often leading to cumbersome and error-prone code, especially when dealing with multiple resources.

### Example of a "Normal Try Block" (Pre-Java 7):

Consider reading from a file using `BufferedReader`.

```java
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

public class TraditionalTryBlockExample {
    public static void main(String[] args) {
        BufferedReader reader = null; // Declare outside try to be accessible in finally
        try {
            reader = new BufferedReader(new FileReader("example.txt"));
            String line;
            while ((line = reader.readLine()) != null) {
                System.out.println(line);
            }
        } catch (IOException e) {
            System.err.println("An error occurred while reading the file: " + e.getMessage());
        } finally {
            // This finally block is crucial to ensure the resource is closed
            if (reader != null) { // Check for null in case an exception occurred during instantiation
                try {
                    reader.close(); // Closing itself can throw an IOException
                    System.out.println("Resource (reader) closed successfully.");
                } catch (IOException e) {
                    System.err.println("Error closing the resource: " + e.getMessage());
                }
            }
        }
    }
}
```

**Problems with the Traditional Approach:**

1.  **Boilerplate Code:** A lot of repetitive code for resource declaration, null checks, and nested `try-catch` for closing.
2.  **Resource Leaks:** If you forget the `finally` block, or make a mistake in it, the resource might not be closed, leading to resource exhaustion (e.g., too many open files).
3.  **Complex Error Handling:** If an exception occurs in the `try` block AND another exception occurs in the `finally` block during `close()`, the original exception can be lost (suppressed by the new one), making debugging harder.

## 3. How `try-with-resources` is Different and Better

`try-with-resources` fundamentally changes resource management by automating the closing process and improving exception handling.

### Example of `try-with-resources`:

```java
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.File; // For creating a dummy file

public class TryWithResourcesExample {
    public static void main(String[] args) {
        // Create a dummy file for demonstration
        createDummyFile("example.txt", "Line 1\nLine 2\nLine 3");

        try (BufferedReader reader = new BufferedReader(new FileReader("example.txt"))) {
            // The reader will be automatically closed at the end of this try block
            String line;
            while ((line = reader.readLine()) != null) {
                System.out.println(line);
            }
            System.out.println("Resource (reader) used and implicitly closed.");
        } catch (IOException e) {
            System.err.println("An error occurred while reading the file: " + e.getMessage());
            e.printStackTrace();
        }
        // No finally block needed for closing the reader!
    }

    private static void createDummyFile(String fileName, String content) {
        try (java.io.FileWriter writer = new java.io.FileWriter(fileName)) {
            writer.write(content);
        } catch (IOException e) {
            System.err.println("Could not create dummy file: " + e.getMessage());
        }
    }
}
```

### Key Differences and Advantages of `try-with-resources`:

1.  **Automatic Resource Closing:**
    * **Normal Try:** Requires explicit `close()` calls in a `finally` block, including `null` checks and nested `try-catch` for the `close()` call itself.
    * **Try-with-resources:** Resources declared in the `try` parentheses are automatically closed by the JVM when the `try` block exits (normally or via exception). No explicit `close()` or `null` checks are needed in your code.

2.  **Reduced Boilerplate Code:**
    * **Normal Try:** More verbose due to resource declaration outside `try`, `finally` block structure, and error handling for closing.
    * **Try-with-resources:** Much more concise and readable, especially for multiple resources.

3.  **Improved Exception Handling (Suppressed Exceptions):**
    * **Normal Try:** If an exception occurs in the `try` block and *another* exception occurs in the `finally` block (e.g., during `close()`), the original exception is "lost" or "suppressed" by the one from the `finally` block. This makes debugging harder as you only see the later exception.
    * **Try-with-resources:** If an exception occurs in the `try` block, and an exception also occurs during the automatic `close()` operation, the exception from the `try` block is the **primary exception**. The exception from the `close()` method is then **suppressed**. You can retrieve suppressed exceptions using `Throwable.getSuppressed()`. This preserves the original cause of the failure, making debugging easier.

4.  **Handling Multiple Resources:**
    * **Normal Try:** Closing multiple resources requires nested `try-finally` blocks or very complex `finally` blocks, quickly becoming unmanageable.
    * **Try-with-resources:** You can declare multiple resources in a single `try` statement, separated by semicolons. They will be closed in the reverse order of their declaration.

    ```java
    // Example with multiple resources using try-with-resources
    import java.io.FileInputStream;
    import java.io.FileOutputStream;

    public class MultipleResourcesExample {
        public static void main(String[] args) {
            try (FileInputStream fis = new FileInputStream("source.txt");
                 FileOutputStream fos = new FileOutputStream("destination.txt")) {
                // Code to read from fis and write to fos
                int byteRead;
                while ((byteRead = fis.read()) != -1) {
                    fos.write(byteRead);
                }
                System.out.println("File copied successfully!");
            } catch (IOException e) {
                System.err.println("Error during file operation: " + e.getMessage());
            }
        }
    }
    ```

In conclusion, `try-with-resources` is a significant enhancement for Java I/O and resource management. It promotes cleaner, safer, and more readable code by automating resource closure and improving the way multiple exceptions are handled. You should always prefer `try-with-resources` over traditional `try-catch-finally` blocks for any resource that implements `AutoCloseable`.

----------------------------------------------------------------------------------------------------------------------------------------------------------

File Handling in Java 


Reading Files 

Reading files in Java is a fundamental I/O operation. Java provides various classes and approaches, depending on whether you're reading text or binary data, and whether you need to read byte by byte, character by character, line by line, or specific data types.

The most crucial aspect of file reading is **ensuring that resources are properly closed** after use, even if an exception occurs. This is best achieved using the **try-with-resources statement** (introduced in Java 7).

Let's explore the common ways:

---

## 1. Reading Text Files

For human-readable text, you typically use character-based streams. You also need to consider **character encoding** (e.g., UTF-8, UTF-16, ISO-8859-1). If not specified, the platform's default encoding is used.

### a. Using `FileReader` (Basic Character Input)

`FileReader` is suitable for reading plain text files, character by character. It's unbuffered, so for large files, it's inefficient. It uses the default character encoding of the system.

**Example:**

```java
import java.io.FileReader;
import java.io.IOException;
import java.io.File; // For creating a dummy file

public class FileReaderExample {
    public static void main(String[] args) {
        String fileName = "example_basic.txt";
        createDummyFile(fileName, "Hello World from FileReader!\nAnother line.");

        try (FileReader reader = new FileReader(fileName)) { // try-with-resources for auto-closing
            int character;
            System.out.println("Reading '" + fileName + "':");
            while ((character = reader.read()) != -1) { // -1 indicates end of stream
                System.out.print((char) character);
            }
            System.out.println("\nFile read successfully.");
        } catch (IOException e) {
            System.err.println("An error occurred while reading the file: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private static void createDummyFile(String fileName, String content) {
        try (java.io.FileWriter writer = new java.io.FileWriter(fileName)) {
            writer.write(content);
        } catch (IOException e) {
            System.err.println("Could not create dummy file: " + e.getMessage());
        }
    }
}
```

### b. Using `BufferedReader` with `FileReader` (Recommended for Text)

`BufferedReader` wraps an underlying `Reader` (like `FileReader`) and adds buffering, which significantly improves performance, especially when reading large files or reading line by line. Its `readLine()` method is very convenient.

**Example:**

```java
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.File;

public class BufferedReaderExample {
    public static void main(String[] args) {
        String fileName = "example_buffered.txt";
        createDummyFile(fileName, "First line with BufferedReader.\nSecond line, this is awesome!");

        try (BufferedReader reader = new BufferedReader(new FileReader(fileName))) {
            String line;
            System.out.println("Reading '" + fileName + "' line by line:");
            while ((line = reader.readLine()) != null) { // readLine() returns null at end of stream
                System.out.println(line);
            }
            System.out.println("File read successfully.");
        } catch (IOException e) {
            System.err.println("An error occurred while reading the file: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private static void createDummyFile(String fileName, String content) {
        try (java.io.FileWriter writer = new java.io.FileWriter(fileName)) {
            writer.write(content);
        } catch (IOException e) {
            System.err.println("Could not create dummy file: " + e.getMessage());
        }
    }
}
```

### c. Using `Scanner` (Convenient for Delimited Text/Primitives)

`Scanner` is a utility class that can parse primitive types and strings using regular expressions. It's very convenient for reading input from various sources, including files, token by token (e.g., word by word, or number by number) or line by line.

**Example:**

```java
import java.io.File;
import java.io.IOException;
import java.util.Scanner;

public class ScannerExample {
    public static void main(String[] args) {
        String fileName = "example_scanner.txt";
        createDummyFile(fileName, "Name: Alice Age: 30\nName: Bob Age: 25");

        try (Scanner scanner = new Scanner(new File(fileName))) {
            System.out.println("Reading '" + fileName + "' with Scanner:");
            while (scanner.hasNextLine()) { // Check if there's another line
                String line = scanner.nextLine();
                // You can then parse the line further
                System.out.println("Line: " + line);

                // Example of parsing tokens from the line
                Scanner lineScanner = new Scanner(line);
                lineScanner.next(); // "Name:"
                String name = lineScanner.next(); // "Alice" or "Bob"
                lineScanner.next(); // "Age:"
                int age = lineScanner.next( ); // 30 or 25
                System.out.println("  Parsed -> Name: " + name + ", Age: " + age);
                lineScanner.close(); // Close the inner scanner
            }
            System.out.println("File read successfully.");
        } catch (IOException e) {
            System.err.println("An error occurred while reading the file: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private static void createDummyFile(String fileName, String content) {
        try (java.io.FileWriter writer = new java.io.FileWriter(fileName)) {
            writer.write(content);
        } catch (IOException e) {
            System.err.println("Could not create dummy file: " + e.getMessage());
        }
    }
}
```

### d. Using `Files.readAllLines()` (NIO.2 - Java 7+ for Small/Medium Text Files)

The `java.nio.file.Files` utility class provides simple, high-level methods. `readAllLines()` reads all lines from a text file into a `List<String>`. This is extremely convenient for smaller files but **should be avoided for very large files** as it loads the entire file content into memory.

**Example:**

```java
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.io.IOException;
import java.util.List;
import java.io.File; // For creating dummy file

public class FilesReadAllLinesExample {
    public static void main(String[] args) {
        Path filePath = Paths.get("example_all_lines.txt");
        createDummyFile(filePath.toString(), "Line A from Files.readAllLines\nLine B from Files.readAllLines");

        try {
            System.out.println("Reading '" + filePath + "' with Files.readAllLines:");
            List<String> lines = Files.readAllLines(filePath); // Reads using UTF-8 by default
            for (String line : lines) {
                System.out.println(line);
            }
            System.out.println("File read successfully.");
        } catch (IOException e) {
            System.err.println("An error occurred: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private static void createDummyFile(String fileName, String content) {
        try (java.io.FileWriter writer = new java.io.FileWriter(fileName)) {
            writer.write(content);
        } catch (IOException e) {
            System.err.println("Could not create dummy file: " + e.getMessage());
        }
    }
}
```

### e. Using `Files.newBufferedReader()` (NIO.2 - Java 7+ for Large Text Files)

This combines the efficiency of `BufferedReader` with the modern `Files` API, allowing you to specify the character set. This is often the preferred method for reading large text files.

**Example:**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.io.File; // For creating dummy file

public class FilesNewBufferedReaderExample {
    public static void main(String[] args) {
        Path filePath = Paths.get("example_new_buffered.txt");
        createDummyFile(filePath.toString(), "Line 1 from newBufferedReader.\nLine 2 with custom encoding.");

        try (BufferedReader reader = Files.newBufferedReader(filePath, StandardCharsets.UTF_8)) {
            String line;
            System.out.println("Reading '" + filePath + "' with Files.newBufferedReader:");
            while ((line = reader.readLine()) != null) {
                System.out.println(line);
            }
            System.out.println("File read successfully.");
        } catch (IOException e) {
            System.err.println("An error occurred: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private static void createDummyFile(String fileName, String content) {
        try (java.io.FileWriter writer = new java.io.FileWriter(fileName)) {
            writer.write(content);
        } catch (IOException e) {
            System.err.println("Could not create dummy file: " + e.getMessage());
        }
    }
}
```

---

## 2. Reading Binary Files

For non-textual data (images, audio, serialized objects, primitive data types), you use byte-based streams.

### a. Using `FileInputStream` (Basic Byte Input)

`FileInputStream` is the raw byte stream reader. It reads bytes directly from a file. It's unbuffered.

**Example:**

```java
import java.io.FileInputStream;
import java.io.IOException;
import java.io.File;
import java.io.FileOutputStream; // For creating dummy binary file

public class FileInputStreamExample {
    public static void main(String[] args) {
        String fileName = "example_binary.bin";
        byte[] dummyData = {0x10, 0x20, 0x30, 0x40, (byte)0xFF};
        createDummyBinaryFile(fileName, dummyData);

        try (FileInputStream fis = new FileInputStream(fileName)) {
            int byteRead;
            System.out.println("Reading '" + fileName + "' byte by byte:");
            while ((byteRead = fis.read()) != -1) {
                System.out.print(String.format("%02X ", byteRead)); // Print in hex format
            }
            System.out.println("\nFile read successfully.");
        } catch (IOException e) {
            System.err.println("An error occurred while reading binary data: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private static void createDummyBinaryFile(String fileName, byte[] data) {
        try (FileOutputStream fos = new FileOutputStream(fileName)) {
            fos.write(data);
        } catch (IOException e) {
            System.err.println("Could not create dummy binary file: " + e.getMessage());
        }
    }
}
```

### b. Using `BufferedInputStream` with `FileInputStream` (Recommended for Binary)

`BufferedInputStream` adds a buffer to the `FileInputStream`, improving performance when reading large binary files.

**Example:**

```java
import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.File;
import java.io.FileOutputStream;

public class BufferedInputStreamExample {
    public static void main(String[] args) {
        String fileName = "example_buffered_binary.bin";
        byte[] dummyData = {0x0A, 0x0B, 0x0C, 0x0D, (byte)0xFE};
        createDummyBinaryFile(fileName, dummyData);

        try (BufferedInputStream bis = new BufferedInputStream(new FileInputStream(fileName))) {
            int byteRead;
            System.out.println("Reading '" + fileName + "' with buffering:");
            while ((byteRead = bis.read()) != -1) {
                System.out.print(String.format("%02X ", byteRead));
            }
            System.out.println("\nFile read successfully.");
        } catch (IOException e) {
            System.err.println("An error occurred while reading buffered binary data: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private static void createDummyBinaryFile(String fileName, byte[] data) {
        try (FileOutputStream fos = new FileOutputStream(fileName)) {
            fos.write(data);
        } catch (IOException e) {
            System.err.println("Could not create dummy binary file: " + e.getMessage());
        }
    }
}
```

### c. Using `DataInputStream` (Reading Primitive Data Types)

`DataInputStream` allows you to read primitive Java data types (like `int`, `double`, `boolean`, `String`) that were written using `DataOutputStream`, ensuring data integrity and portability.

**Example (Requires a file written by `DataOutputStreamExample` from previous response):**

```java
import java.io.DataInputStream;
import java.io.FileInputStream;
import java.io.IOException;

public class DataInputStreamExample {
    public static void main(String[] args) {
        String fileName = "primitiveData.dat"; // Assuming this file was created by DataOutputStreamExample

        try (DataInputStream dis = new DataInputStream(new FileInputStream(fileName))) {
            System.out.println("Reading primitive data from '" + fileName + "':");
            int anInt = dis.readInt();
            double aDouble = dis.readDouble();
            boolean aBoolean = dis.readBoolean();
            String aString = dis.readUTF();

            System.out.println("Int: " + anInt);
            System.out.println("Double: " + aDouble);
            System.out.println("Boolean: " + aBoolean);
            System.out.println("String: " + aString);
            System.out.println("File read successfully.");
        } catch (IOException e) {
            System.err.println("An error occurred while reading primitive data: " + e.getMessage());
            e.printStackTrace();
        }
    }
}
```

### d. Using `Files.readAllBytes()` (NIO.2 - Java 7+ for Small/Medium Binary Files)

Similar to `readAllLines()`, `readAllBytes()` reads the entire content of a file into a `byte[]`. Convenient for small to medium binary files, but not for very large ones (due to memory consumption).

**Example:**

```java
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.io.IOException;
import java.io.File;
import java.io.FileOutputStream; // For creating dummy binary file

public class FilesReadAllBytesExample {
    public static void main(String[] args) {
        Path filePath = Paths.get("example_all_bytes.bin");
        byte[] dummyData = {0x01, 0x02, 0x03, 0x04};
        createDummyBinaryFile(filePath.toString(), dummyData);

        try {
            System.out.println("Reading '" + filePath + "' with Files.readAllBytes:");
            byte[] fileContent = Files.readAllBytes(filePath);
            for (byte b : fileContent) {
                System.out.print(String.format("%02X ", b));
            }
            System.out.println("\nFile read successfully.");
        } catch (IOException e) {
            System.err.println("An error occurred: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private static void createDummyBinaryFile(String fileName, byte[] data) {
        try (FileOutputStream fos = new FileOutputStream(fileName)) {
            fos.write(data);
        } catch (IOException e) {
            System.err.println("Could not create dummy binary file: " + e.getMessage());
        }
    }
}
```

---

## Important Considerations for File Reading:

1.  **Closing Resources (`try-with-resources`):** Always use `try-with-resources` (Java 7+) to ensure that all input streams are automatically closed, preventing resource leaks. This is the most important best practice.

2.  **Character Encoding:**
    * For text files, explicitly specify the character encoding (e.g., `StandardCharsets.UTF_8`) when using `FileReader` (by wrapping it in `InputStreamReader` and `BufferedReader`) or `Files.newBufferedReader()`.
    * `FileReader` and `Scanner`'s default behavior typically uses the platform's default encoding, which can lead to issues when reading files created on different systems.

    ```java
    // Example with explicit encoding
    import java.io.BufferedReader;
    import java.io.FileInputStream;
    import java.io.IOException;
    import java.io.InputStreamReader;
    import java.nio.charset.StandardCharsets;

    try (BufferedReader reader = new BufferedReader(
             new InputStreamReader(new FileInputStream("my_utf8_file.txt"), StandardCharsets.UTF_8))) {
        // ... read lines
    }
    ```

3.  **Error Handling (`IOException`):** All file I/O operations can throw `IOException` (a checked exception), which you must handle using `try-catch` or declare using `throws` in the method signature. Specifically, `FileNotFoundException` is a common subclass of `IOException` that indicates the file does not exist at the specified path.

By understanding these various methods and best practices, you can efficiently and safely read files in Java for diverse application needs.

---------------------

Writing Files 

Writing files in Java is a fundamental I/O operation. Java provides various classes and approaches, depending on whether you're writing text or binary data, and whether you prioritize simplicity, performance, or specific formatting.

The most crucial aspect of file writing is **ensuring that resources are properly closed** after use, even if an exception occurs. This is best achieved using the **try-with-resources statement** (introduced in Java 7).

Let's explore the common ways:

---

## 1. Writing Text Files

For writing human-readable text, you typically use character-based streams.

### a. Using `FileWriter` (Basic Character Output)

`FileWriter` is suitable for writing plain text to a file. It writes characters directly. It's generally not recommended for large files as it doesn't buffer output, which can be inefficient.

**Example:**

```java
import java.io.FileWriter;
import java.io.IOException;

public class FileWriterExample {
    public static void main(String[] args) {
        String fileName = "myFile.txt";
        String content = "Hello, this is a test line.\n";
        content += "This is the second line.";

        try (FileWriter writer = new FileWriter(fileName)) { // try-with-resources for auto-closing
            writer.write(content);
            System.out.println("Content written to " + fileName + " successfully.");
        } catch (IOException e) {
            System.err.println("An error occurred while writing the file: " + e.getMessage());
            e.printStackTrace();
        }
    }
}
```

### b. Using `BufferedWriter` with `FileWriter` (Buffered Character Output)

`BufferedWriter` adds a buffer to the `FileWriter`, which significantly improves performance, especially when writing many small chunks of data. It's almost always recommended when writing text files.

**Example:**

```java
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;

public class BufferedWriterExample {
    public static void main(String[] args) {
        String fileName = "bufferedFile.txt";
        String line1 = "This is the first line written with a BufferedWriter.";
        String line2 = "This is the second line.";

        try (BufferedWriter writer = new BufferedWriter(new FileWriter(fileName))) {
            writer.write(line1);
            writer.newLine(); // Writes a system-dependent new line character
            writer.write(line2);
            System.out.println("Content written to " + fileName + " with buffering.");
        } catch (IOException e) {
            System.err.println("An error occurred while writing the file: " + e.getMessage());
            e.printStackTrace();
        }
    }
}
```

### c. Using `PrintWriter` (Formatted Character Output)

`PrintWriter` builds on `BufferedWriter` and `FileWriter` by providing convenient methods like `print()`, `println()`, and `printf()` (for formatted output, similar to C's `printf`). It's very useful for generating reports or structured text files.

**Example:**

```java
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;

public class PrintWriterExample {
    public static void main(String[] args) {
        String fileName = "printWriterFile.txt";
        String name = "Alice";
        int age = 30;
        double salary = 75000.50;

        try (PrintWriter writer = new PrintWriter(new FileWriter(fileName))) {
            writer.println("User Report:"); // Writes a line and then a new line
            writer.printf("Name: %s%n", name); // Formatted output
            writer.printf("Age: %d years%n", age);
            writer.printf("Salary: %.2f%n", salary); // Formatted to 2 decimal places
            System.out.println("Content written to " + fileName + " using PrintWriter.");
        } catch (IOException e) {
            System.err.println("An error occurred while writing the file: " + e.getMessage());
            e.printStackTrace();
        }
    }
}
```
**Note on `PrintWriter` auto-flushing:** You can enable auto-flushing (writing buffer to file after each `println()` or `printf()` call) by using `new PrintWriter(new FileWriter(fileName), true)`.

### d. Using `Files.write()` (NIO.2 - Java 7+ for Text)

The `java.nio.file.Files` utility class provides very simple methods for common file operations, including writing. For text, it often takes an `Iterable<CharSequence>` (like a `List<String>`) or `byte[]` and handles the boilerplate code (opening, writing, closing) automatically. It's excellent for simple scenarios.

**Example (Writing lines from a List):**

```java
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.io.IOException;
import java.util.Arrays;
import java.util.List;
import static java.nio.file.StandardOpenOption.APPEND; // For appending

public class FilesWriteTextExample {
    public static void main(String[] args) {
        Path filePath = Paths.get("nio2_text_file.txt");
        List<String> lines = Arrays.asList("First line from Files.write", "Second line from Files.write");

        try {
            // Write (overwrite by default)
            Files.write(filePath, lines);
            System.out.println("Lines written to " + filePath + " (overwritten).");

            // Append mode
            Files.write(filePath, Arrays.asList("Third line (appended)"), APPEND);
            System.out.println("Another line appended to " + filePath + ".");

        } catch (IOException e) {
            System.err.println("An error occurred: " + e.getMessage());
            e.printStackTrace();
        }
    }
}
```

### e. Using `Files.newBufferedWriter()` (NIO.2 - Java 7+ for Text)

This combines the power of `BufferedWriter` for efficiency with the `Files` utility for creating the stream, allowing you to specify `Charset` and `StandardOpenOption`.

**Example:**

```java
import java.io.BufferedWriter;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import static java.nio.file.StandardOpenOption.CREATE;
import static java.nio.file.StandardOpenOption.WRITE;

public class FilesNewBufferedWriterExample {
    public static void main(String[] args) {
        Path filePath = Paths.get("nio2_buffered_writer.txt");

        try (BufferedWriter writer = Files.newBufferedWriter(filePath, StandardCharsets.UTF_8, CREATE, WRITE)) {
            writer.write("Hello, world from newBufferedWriter!");
            writer.newLine();
            writer.write("This is a Unicode test: Êó•Êú¨Ë™û");
            System.out.println("Content written to " + filePath + " using Files.newBufferedWriter.");
        } catch (IOException e) {
            System.err.println("An error occurred: " + e.getMessage());
            e.printStackTrace();
        }
    }
}
```

---

## 2. Writing Binary Files

For writing non-textual data (images, audio, serialized objects, primitive data types), you use byte-based streams.

### a. Using `FileOutputStream` (Basic Byte Output)

`FileOutputStream` is the raw byte stream writer. It writes bytes directly to a file. Similar to `FileWriter`, it's unbuffered, so for performance, it's often wrapped in a `BufferedOutputStream`.

**Example:**

```java
import java.io.FileOutputStream;
import java.io.IOException;

public class FileOutputStreamExample {
    public static void main(String[] args) {
        String fileName = "binaryFile.bin";
        byte[] data = {0x01, 0x02, 0x03, 0x04, (byte) 0xFF}; // Some sample bytes

        try (FileOutputStream fos = new FileOutputStream(fileName)) {
            fos.write(data);
            System.out.println("Binary data written to " + fileName + ".");
        } catch (IOException e) {
            System.err.println("An error occurred while writing binary data: " + e.getMessage());
            e.printStackTrace();
        }
    }
}
```

### b. Using `BufferedOutputStream` with `FileOutputStream` (Buffered Byte Output)

Similar to `BufferedWriter`, `BufferedOutputStream` adds a buffer for efficiency when writing bytes.

**Example:**

```java
import java.io.BufferedOutputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class BufferedOutputStreamExample {
    public static void main(String[] args) {
        String fileName = "bufferedBinaryFile.bin";
        byte[] data = {0x0A, 0x0B, 0x0C, 0x0D, (byte) 0xEE};

        try (BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(fileName))) {
            bos.write(data);
            System.out.println("Binary data written to " + fileName + " with buffering.");
        } catch (IOException e) {
            System.err.println("An error occurred while writing buffered binary data: " + e.getMessage());
            e.printStackTrace();
        }
    }
}
```

### c. Using `DataOutputStream` (Writing Primitive Data Types)

`DataOutputStream` allows you to write primitive Java data types (like `int`, `double`, `boolean`, `String`) in a portable binary format. This is useful if you want to read them back later using `DataInputStream`.

**Example:**

```java
import java.io.DataOutputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class DataOutputStreamExample {
    public static void main(String[] args) {
        String fileName = "primitiveData.dat";

        try (DataOutputStream dos = new DataOutputStream(new FileOutputStream(fileName))) {
            dos.writeInt(12345);
            dos.writeDouble(3.14159);
            dos.writeBoolean(true);
            dos.writeUTF("Hello, DataOutputStream!"); // Writes a String in UTF-8 format
            System.out.println("Primitive data written to " + fileName + ".");
        } catch (IOException e) {
            System.err.println("An error occurred while writing primitive data: " + e.getMessage());
            e.printStackTrace();
        }
    }
}
```

### d. Using `Files.write()` (NIO.2 - Java 7+ for Bytes)

The `Files.write()` method can also take a `byte[]` for simple binary writing.

**Example:**

```java
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.io.IOException;

public class FilesWriteBytesExample {
    public static void main(String[] args) {
        Path filePath = Paths.get("nio2_binary_file.bin");
        byte[] data = {0x0F, 0x0E, 0x0D, 0x0C}; // Some sample binary data

        try {
            Files.write(filePath, data); // Overwrites by default
            System.out.println("Binary data written to " + filePath + " using Files.write.");
        } catch (IOException e) {
            System.err.println("An error occurred: " + e.getMessage());
            e.printStackTrace();
        }
    }
}
```

---

## Important Considerations for File Writing:

1.  **Closing Resources (Crucial!):** Always close your streams.
    * **`try-with-resources` (Recommended for Java 7+):** This is the safest and most concise way. Any resource declared within the `try` parentheses that implements `java.lang.AutoCloseable` will be automatically closed when the `try` block exits, whether normally or due to an exception.
    * **`finally` block (Older approach):** Before Java 7, you'd put `close()` calls in a `finally` block to ensure they execute.

2.  **Character Encoding:**
    * When writing text, always consider the character encoding (e.g., UTF-8, UTF-16, ISO-8859-1).
    * `FileWriter` uses the default platform encoding. For explicit control, use `OutputStreamWriter` wrapped in a `BufferedWriter`, specifying the `Charset`:
        ```java
        try (BufferedWriter writer = new BufferedWriter(
                 new OutputStreamWriter(new FileOutputStream(fileName), StandardCharsets.UTF_8))) {
            writer.write("Your Unicode text here: Êó•Êú¨Ë™û");
        }
        ```
    * `Files.write()` and `Files.newBufferedWriter()` allow you to specify the `Charset` directly.

3.  **Overwriting vs. Appending:**
    * By default, `FileWriter`, `FileOutputStream`, and `Files.write()` will **overwrite** the file if it already exists.
    * To **append** to an existing file, use the `true` argument in the constructor for `FileWriter` or `FileOutputStream`:
        ```java
        new FileWriter(fileName, true) // Append mode for FileWriter
        new FileOutputStream(fileName, true) // Append mode for FileOutputStream
        ```
    * For `Files.write()` and `Files.newBufferedWriter()`, use `StandardOpenOption.APPEND`:
        ```java
        Files.write(filePath, lines, StandardOpenOption.APPEND);
        Files.newBufferedWriter(filePath, StandardCharsets.UTF_8, StandardOpenOption.APPEND);
        ```

4.  **Error Handling (`IOException`):** All file I/O operations can throw `IOException` (a checked exception), which you must handle (using `try-catch`) or declare (`throws`).

By understanding these different approaches and best practices, you can effectively write files in Java for various purposes.

-----------------------------------------------------------------------------------------------------------------------------------------------------------

Anonymous Classes in Java

Anonymous classes in Java are a powerful feature that allows you to define and instantiate a class at the same time, without needing to give it a name. They are often used for creating quick implementations of interfaces or abstract classes, especially when you need to override methods in a concise way.
Anonymous classes are particularly useful in scenarios like event handling, callbacks, or when you need a one-off implementation of an interface or abstract class.

public class Main {
    public static void main(String[] args) {

        // Anonymous class = A class that doesn't have a name. Cannot be reused.
        //                                     Add custom behavior without having to create a new class.
        //                                     Often used for one time uses (TimerTask, Runnable, callbacks)

        Dog dog1 = new Dog();
        Dog dog2 = new Dog(){
            // OverRides the existing speak method in Dog without creating a new class
            @Override
            void speak(){
                System.out.println("Scooby Doo says *Ruh Roh*");
            }
        };

        dog1.speak();
        dog2.speak();
    }
}

public class Dog {

    void speak(){
        System.out.println("The dog goes *woof*");
    }
}

---------------------------------------------------------------------------------------------------------------------------------------------------------

Timer and TimerTasks in Java 

In Java, the `Timer` and `TimerTask` classes, found in the `java.util` package, are used to schedule tasks to run at a specific time or repeatedly at fixed intervals.

* **Timer:** The `Timer` class is a utility class that allows you to schedule tasks for one-time execution or repeated execution. You create a `Timer` object, and then use its methods to schedule `TimerTask` objects.
* **TimerTask:** The `TimerTask` is an abstract class that represents a task that can be scheduled by a `Timer`. You need to extend `TimerTask` and override its `run()` method with the code that you want to execute when the task runs.

Here's an example:

```java
import java.util.Timer;
import java.util.TimerTask;

public class TimerExample {

    public static void main(String[] args) {
        Timer timer = new Timer();

        TimerTask task1 = new TimerTask() {
            @Override
            public void run() {
                System.out.println("Task 1 executed!");
            }
        };

        TimerTask task2 = new TimerTask() {
            @Override
            public void run() {
                System.out.println("Task 2 executed repeatedly!");
            }
        };

        // Schedule task1 to run once after a 1-second delay
        timer.schedule(task1, 1000);

        // Schedule task2 to run repeatedly, starting after a 2-second delay, and then every 3 seconds
        timer.schedule(task2, 2000, 3000);

        // Schedule task2 to run repeatedly at a fixed rate
        timer.scheduleAtFixedRate(task2, 2000, 3000);

        // Cancel the timer after 10 seconds (to prevent tasks from running indefinitely)
        timer.schedule(new TimerTask() {
            @Override
            public void run() {
                timer.cancel();
                System.out.println("Timer cancelled!");
            }
        }, 10000);
    }
}
```

Key methods of the `Timer` class:

* `schedule(TimerTask task, Date time)`: Schedules the specified task for execution at the specified time.
* `schedule(TimerTask task, long delay)`: Schedules the specified task for execution after the specified delay in milliseconds.
* `schedule(TimerTask task, Date firstTime, long period)`: Schedules the specified task for repeated fixed-delay execution, beginning at the specified time.
* `schedule(TimerTask task, long delay, long period)`: Schedules the specified task for repeated fixed-delay execution, beginning after the specified delay in milliseconds.
* `scheduleAtFixedRate(TimerTask task, Date firstTime, long period)`: Schedules the specified task for repeated fixed-rate execution, beginning at the specified time.
* `scheduleAtFixedRate(TimerTask task, long delay, long period)`: Schedules the specified task for repeated fixed-rate execution, beginning after the specified delay in milliseconds.
* `cancel()`: Terminates this timer, canceling any currently scheduled tasks.

`Timer` and `TimerTask` are suitable for many basic scheduling needs. However, for more complex scenarios, especially in concurrent environments, consider using the `ScheduledExecutorService`, which provides more control and features.

----------------------------------------------------------------------------------------------------------------------------------------------------------

Generics in Java 

public class Main {
   public static void main(String[] args) {

// Generics = A concept where you can write a class, interface, or method
//                     that is compatible with different data types.
//                    <T> type parameter (placeholder that gets replaced with a real type)
//                    <String> type argument (specifies the type)

       Box<String> box = new Box<>();
       box.setItem("banana");
       System.out.println(box.getItem());

       Product<String, Double> product1 = new Product<>("apple", 0.50);
       Product<String, Integer> product2 = new Product<>("ticket", 15);
   }
}
public class Box<T>{

   T item;

   public void setItem(T item){
       this.item = item;
   }

   public T getItem(){
       return item;
   }
}
public class Product<T, U> {

   T item;
   U price;

   public Product(T item, U price){
       this.item = item;
       this.price = price;
   }

   public T getItem(){
       return this.item;
   }

   public U getPrice(){
       return this.price;
   }
}

-----------------------------------------------------------------------------------------------------------------------------------------------------------

Sets and Maps in Java 

In Java, `Set` and `HashMap` are fundamental interfaces and classes from the **Java Collections Framework**, used for storing and managing groups of objects. They serve different purposes based on their underlying data structures and rules.

---

## 1. `Set` in Java

A `Set` is an interface in Java (`java.util.Set`) that represents a collection which **does not contain duplicate elements**. It models the mathematical set abstraction.

### Key Characteristics of a `Set`:

* **No Duplicates:** The most defining characteristic. If you try to add an element that already exists, the `add()` method will return `false`, and the set's size will not change.
* **Unordered (Generally):** Most `Set` implementations (like `HashSet`) do not guarantee the order of elements. The order might change over time, or vary across different runs.
* **Allows at most one `null` element.**
* **Backed by a `Map` internally:** `HashSet`, for example, internally uses a `HashMap` where elements are stored as keys, and a dummy `Object` is stored as values.

### Common `Set` Implementations:

1.  **`HashSet` (Most Common):**
    * Uses a hash table for storage.
    * Offers constant-time performance (O(1)) for basic operations like `add`, `remove`, `contains`, `size` on average, assuming a good hash function.
    * Does **not** maintain any insertion order or sorted order.
    * **Not synchronized** (not thread-safe).

2.  **`LinkedHashSet`:**
    * Maintains a hash table with a linked list running through it.
    * Preserves the **insertion order** of elements.
    * Performance is slightly worse than `HashSet` but still good (near O(1)).
    * **Not synchronized**.

3.  **`TreeSet`:**
    * Stores elements in a **sorted order** (natural order or by a custom `Comparator`).
    * Uses a balanced binary search tree (Red-Black tree) for storage.
    * Performance for basic operations is O(log n).
    * **Not synchronized**.

### Common `Set` Methods with Examples (`HashSet` example):

```java
import java.util.HashSet;
import java.util.Set;
import java.util.Iterator; // For iterating

public class SetExample {
    public static void main(String[] args) {
        // Create a HashSet of Strings
        Set<String> uniqueColors = new HashSet<>();

        // 1. add(E e): Adds an element to the set. Returns true if added, false if duplicate.
        System.out.println("Adding Red: " + uniqueColors.add("Red"));    // true
        System.out.println("Adding Green: " + uniqueColors.add("Green"));  // true
        System.out.println("Adding Blue: " + uniqueColors.add("Blue"));   // true
        System.out.println("Adding Red again: " + uniqueColors.add("Red")); // false (duplicate)
        System.out.println("Colors in set: " + uniqueColors); // Order is not guaranteed, e.g., [Red, Blue, Green]

        // 2. size(): Returns the number of elements in the set.
        System.out.println("Size of set: " + uniqueColors.size()); // 3

        // 3. contains(Object o): Returns true if the set contains the specified element.
        System.out.println("Contains Green? " + uniqueColors.contains("Green")); // true
        System.out.println("Contains Yellow? " + uniqueColors.contains("Yellow")); // false

        // 4. remove(Object o): Removes the specified element from the set. Returns true if removed.
        System.out.println("Removing Blue: " + uniqueColors.remove("Blue"));   // true
        System.out.println("Removing Orange: " + uniqueColors.remove("Orange")); // false (not present)
        System.out.println("Colors after removal: " + uniqueColors); // e.g., [Red, Green]

        // 5. isEmpty(): Returns true if the set contains no elements.
        System.out.println("Is set empty? " + uniqueColors.isEmpty()); // false

        // 6. Iterating through a Set (using Iterator or enhanced for loop)
        System.out.println("Iterating through colors:");
        for (String color : uniqueColors) {
            System.out.println("- " + color);
        }

        // Using Iterator (more control)
        Iterator<String> it = uniqueColors.iterator();
        while (it.hasNext()) {
            String color = it.next();
            // it.remove(); // Can remove elements safely during iteration
        }

        // 7. addAll(Collection<? extends E> c): Adds all elements from another collection.
        Set<String> moreColors = new HashSet<>();
        moreColors.add("Yellow");
        moreColors.add("Purple");
        uniqueColors.addAll(moreColors); // Adds Yellow and Purple
        System.out.println("After addAll: " + uniqueColors); // e.g., [Red, Green, Yellow, Purple]

        // 8. removeAll(Collection<?> c): Removes all elements that are also in the specified collection.
        Set<String> colorsToRemove = new HashSet<>();
        colorsToRemove.add("Red");
        colorsToRemove.add("Yellow");
        uniqueColors.removeAll(colorsToRemove);
        System.out.println("After removeAll (Red, Yellow): " + uniqueColors); // e.g., [Green, Purple]

        // 9. retainAll(Collection<?> c): Retains only the elements that are also in the specified collection.
        Set<String> colorsToRetain = new HashSet<>();
        colorsToRetain.add("Green");
        colorsToRetain.add("Orange"); // Orange is not in uniqueColors, so it's ignored
        uniqueColors.retainAll(colorsToRetain);
        System.out.println("After retainAll (Green, Orange): " + uniqueColors); // e.g., [Green]

        // 10. clear(): Removes all elements from the set.
        uniqueColors.clear();
        System.out.println("After clear: " + uniqueColors); // []
        System.out.println("Is set empty after clear? " + uniqueColors.isEmpty()); // true
    }
}
```

---

## 2. `HashMap` in Java

A `HashMap` is a class in Java (`java.util.HashMap`) that implements the `Map` interface. It stores data in **key-value pairs**. Each key must be unique, but multiple keys can map to the same value.

### Key Characteristics of a `HashMap`:

* **Key-Value Pairs:** Stores associations between a unique key and a corresponding value.
* **Unique Keys:** Each key in a `HashMap` must be unique. If you try to `put()` a value with a key that already exists, the old value associated with that key will be replaced.
* **Unordered (Generally):** `HashMap` does not guarantee any specific order of elements. The order may change over time, or vary across different JVM implementations.
* **Allows one `null` key** and **multiple `null` values**.
* **Hashing Mechanism:** It uses a hash table for storage, providing very fast (average constant time, O(1)) operations like `get` and `put`, assuming a good hash function.

### Common `Map` Implementations (of which `HashMap` is one):

1.  **`HashMap` (Most Common):**
    * Uses a hash table.
    * Best average-case performance (O(1)) for basic operations.
    * Does **not** maintain order.
    * **Not synchronized** (not thread-safe).

2.  **`LinkedHashMap`:**
    * Maintains a hash table and a doubly-linked list.
    * Preserves the **insertion order** of key-value pairs.
    * Performance is slightly lower than `HashMap` but still good.
    * **Not synchronized**.

3.  **`TreeMap`:**
    * Stores entries in **sorted order** based on the natural ordering of its keys or by a custom `Comparator`.
    * Uses a Red-Black tree structure.
    * Performance for basic operations is O(log n).
    * **Not synchronized**.

### Common `HashMap` Methods with Examples:

```java
import java.util.HashMap;
import java.util.Map;
import java.util.Set; // For keySet() and entrySet()
import java.util.Collection; // For values()

public class HashMapExample {
    public static void main(String[] args) {
        // Create a HashMap where keys are String (country codes) and values are String (country names)
        Map<String, String> countryMap = new HashMap<>();

        // 1. put(K key, V value): Associates the specified value with the specified key.
        System.out.println("Putting US: " + countryMap.put("US", "United States")); // null (no previous value)
        System.out.println("Putting CA: " + countryMap.put("CA", "Canada"));    // null
        System.out.println("Putting MX: " + countryMap.put("MX", "Mexico"));    // null
        System.out.println("Putting US again: " + countryMap.put("US", "United States of America")); // "United States" (old value)
        System.out.println("Country map: " + countryMap); // e.g., {US=United States of America, CA=Canada, MX=Mexico}

        // 2. get(Object key): Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key.
        System.out.println("Value for US: " + countryMap.get("US"));     // United States of America
        System.out.println("Value for FR: " + countryMap.get("FR"));     // null

        // 3. size(): Returns the number of key-value mappings in this map.
        System.out.println("Size of map: " + countryMap.size()); // 3

        // 4. containsKey(Object key): Returns true if this map contains a mapping for the specified key.
        System.out.println("Contains key 'CA'? " + countryMap.containsKey("CA")); // true
        System.out.println("Contains key 'DE'? " + countryMap.containsKey("DE")); // false

        // 5. containsValue(Object value): Returns true if this map maps one or more keys to the specified value.
        System.out.println("Contains value 'Canada'? " + countryMap.containsValue("Canada")); // true
        System.out.println("Contains value 'Germany'? " + countryMap.containsValue("Germany")); // false

        // 6. remove(Object key): Removes the mapping for a key from this map if it is present. Returns the value that was removed.
        System.out.println("Removing 'MX': " + countryMap.remove("MX")); // Mexico
        System.out.println("Map after removing MX: " + countryMap); // e.g., {US=United States of America, CA=Canada}

        // 7. isEmpty(): Returns true if this map contains no key-value mappings.
        System.out.println("Is map empty? " + countryMap.isEmpty()); // false

        // 8. keySet(): Returns a Set view of the keys contained in this map.
        Set<String> keys = countryMap.keySet();
        System.out.println("Keys in map: " + keys); // e.g., [US, CA]

        // 9. values(): Returns a Collection view of the values contained in this map.
        Collection<String> values = countryMap.values();
        System.out.println("Values in map: " + values); // e.g., [United States of America, Canada]

        // 10. entrySet(): Returns a Set view of the mappings contained in this map. Each element is a Map.Entry.
        Set<Map.Entry<String, String>> entries = countryMap.entrySet();
        System.out.println("Entries in map:");
        for (Map.Entry<String, String> entry : entries) {
            System.out.println("  Key: " + entry.getKey() + ", Value: " + entry.getValue());
        }

        // 11. putAll(Map<? extends K, ? extends V> m): Copies all of the mappings from the specified map to this map.
        Map<String, String> moreCountries = new HashMap<>();
        moreCountries.put("DE", "Germany");
        moreCountries.put("FR", "France");
        countryMap.putAll(moreCountries);
        System.out.println("After putAll: " + countryMap); // {US=..., CA=..., DE=Germany, FR=France}

        // 12. getOrDefault(Object key, V defaultValue) (Java 8+): Returns the value for the key, or a default if not found.
        System.out.println("Value for 'IT' (default 'Italy'): " + countryMap.getOrDefault("IT", "Italy")); // Italy
        System.out.println("Value for 'CA' (default 'Default'): " + countryMap.getOrDefault("CA", "Default")); // Canada

        // 13. forEach(BiConsumer<? super K, ? super V> action) (Java 8+): Performs the given action for each entry in this map.
        System.out.println("Using forEach:");
        countryMap.forEach((key, value) -> System.out.println("  " + key + " -> " + value));

        // 14. clear(): Removes all of the mappings from this map.
        countryMap.clear();
        System.out.println("After clear: " + countryMap); // {}
        System.out.println("Is map empty after clear? " + countryMap.isEmpty()); // true
    }
}
```

---

## Important Considerations for Both `Set` and `HashMap`:

1.  **`hashCode()` and `equals()`:**
    * For custom objects used as elements in a `HashSet` or as keys in a `HashMap`, it is **absolutely critical** to properly override both the `hashCode()` and `equals()` methods.
    * **Rule:** If two objects are `equals()` according to your definition, their `hashCode()` must be the same. If `hashCode()` values are different, the objects are considered unequal.
    * Failure to do so will lead to incorrect behavior (e.g., duplicates in a `Set`, or `HashMap` not finding keys even if they contain the "same" data).

2.  **Thread-Safety:**
    * Both `HashSet` and `HashMap` are **not thread-safe**. If multiple threads access and modify them concurrently, you can get inconsistent results or even `ConcurrentModificationException`.
    * For thread-safe alternatives:
        * Use `Collections.synchronizedSet(new HashSet<...>)` or `Collections.synchronizedMap(new HashMap<...>)` for synchronized wrappers.
        * For higher concurrency and better performance in multi-threaded environments, use classes from `java.util.concurrent`, such as `ConcurrentHashMap` or `ConcurrentSkipListSet`.

By understanding the distinct characteristics and available methods of `Set` and `HashMap`, you can effectively choose and utilize the right collection for your data storage needs in Java.

----------------------------------------------------------------------------------------------------------------------------------------------------------

Enums in Java 

Enums (short for enumerations) in Java are a special kind of class that represent a fixed set of constants. They are used when you have a collection of items that are closely related and represent a finite, unchanging set of values.

Think of it as a way to define a type that can only have a limited, predefined number of valid values.

**Key Characteristics:**

* **Fixed Set of Constants:** An enum defines a specific list of named constants.
* **Type Safety:** Enums are type-safe. You cannot assign any value outside the defined enum constants. This prevents common errors like typos in strings.
* **More Than Just Integers:** Unlike enums in some other languages (like C++), Java enums are full-fledged objects. They can have fields, methods, and constructors (though enum constructors are implicitly `private`).
* **Improved Readability:** Using meaningful enum names makes code much more readable and self-documenting compared to using arbitrary integer constants or strings.

**Basic Example:**

Let's say you want to represent the days of the week. Instead of using `String`s like "MONDAY", "TUESDAY", etc., or `int`s like 1, 2, 3, you can use an enum:

```java
public class EnumExample {

    // 1. Defining an Enum
    public enum Day {
        SUNDAY,
        MONDAY,
        TUESDAY,
        WEDNESDAY,
        THURSDAY,
        FRIDAY,
        SATURDAY
    }

    public static void main(String[] args) {
        // 2. Using Enum Constants
        Day today = Day.WEDNESDAY;
        Day holiday = Day.SUNDAY;

        // 3. Comparing Enum Constants (using == is safe and recommended)
        if (today == Day.WEDNESDAY) {
            System.out.println("It's hump day!");
        }

        // 4. Using Enums in switch statements (very common and clear)
        switch (holiday) {
            case SATURDAY:
            case SUNDAY:
                System.out.println("It's the weekend!");
                break;
            default:
                System.out.println("It's a weekday.");
        }

        // 5. Iterating over Enum Constants
        System.out.println("\nAll days of the week:");
        for (Day day : Day.values()) { // .values() returns an array of all enum constants
            System.out.println(day);
        }

        // 6. Converting String to Enum
        String dayString = "FRIDAY";
        Day parsedDay = Day.valueOf(dayString); // Throws IllegalArgumentException if not found
        System.out.println("\nParsed day from string: " + parsedDay);
    }
}
```

In this example, `Day` is an enum with seven predefined constant values (`SUNDAY`, `MONDAY`, etc.). These constants are treated as static final instances of the `Day` enum itself. This provides a type-safe and readable way to represent a fixed set of choices.

------------------------------------------------------------------------------------------------------------------------------------------------------------

Threads and MultiThreading in Java 

Multithreading is a powerful concept in Java that allows your program to perform multiple tasks concurrently. It's like juggling several balls at once instead of catching one, setting it down, picking up another, and so on.

Let's break it down in detail, starting from the basics.

---

## 1. Programs and Processes

Before understanding threads, let's clarify `Program` and `Process`:

* **Program:** A set of instructions (code) stored on a disk (e.g., your `.java` files, `.exe` files). It's static; it doesn't do anything until it's run.
* **Process:** An instance of a program that is currently being executed by the operating system. When you double-click an `.exe` file or run a Java program, you create a process. Each process has its own dedicated memory space, resources, etc.

Think of a program as a recipe book, and a process as someone actually *cooking* a dish using that recipe.

---

## 2. What is a Thread?

A **thread** is a lightweight **subprocess** or the smallest unit of execution within a process. A single process can have multiple threads, and these threads share the same memory space and resources of that process.

* **Single-threaded program:** Executes instructions sequentially, one after another, in a single flow.
* **Multi-threaded program:** Executes instructions concurrently in multiple independent flows within the same process.

**Analogy:** Imagine a factory (your computer's CPU) that builds cars (runs processes).
* **Single-threaded:** The factory has only one assembly line (thread). Cars are built strictly one after another.
* **Multi-threaded:** The factory has multiple assembly lines (threads) running simultaneously. Each line can work on a different part of the same car, or even different cars, leading to faster production and better resource utilization. All assembly lines share the factory's resources (power, raw materials storage).

---

## 3. What is Multithreading?

**Multithreading** is the ability of a program to execute multiple parts of its code (threads) concurrently. This means that at any given moment, the operating system or JVM can switch between these threads, giving the illusion (or actual reality on multi-core CPUs) that they are running at the same time.

* **Concurrency:** Multiple tasks making progress in overlapping time periods. They might not literally run at the exact same instant, but they appear to.
* **Parallelism:** Multiple tasks literally running at the exact same instant, typically on different CPU cores. Multithreading enables parallelism.

---

## 4. Why Use Multithreading in Java? (Benefits)

1.  **Responsiveness:** In GUI applications, long-running tasks can be put on a separate thread, preventing the user interface from freezing.
2.  **Performance:** On multi-core processors, threads can truly run in parallel, significantly speeding up computation-heavy tasks.
3.  **Resource Sharing:** Threads within the same process share memory. This makes sharing data between them very efficient, unlike processes which require inter-process communication.
4.  **Reduced Resource Consumption:** Creating a new thread is less resource-intensive (memory, CPU) than creating a new separate process.
5.  **Simplicity (for specific tasks):** Some problems are naturally suited for concurrent execution (e.g., a server handling multiple client requests simultaneously).

---

## 5. How to Create Threads in Java (Beginner-Friendly Ways)

There are two primary ways to create threads in Java:

### a) By Extending the `Thread` Class

1.  Create a new class that `extends java.lang.Thread`.
2.  Override the `public void run()` method. This `run()` method contains the code that the new thread will execute.
3.  Create an instance of your custom `Thread` class.
4.  Call the `start()` method on your thread instance. **Crucially, do NOT call `run()` directly!**

**Example 1: Extending `Thread`**

```java
// Step 1 & 2: Create a class that extends Thread and override run()
class MyThread extends Thread {
    private String threadName;

    public MyThread(String name) {
        this.threadName = name;
        System.out.println(threadName + " is being created.");
    }

    @Override // This method contains the code that will run in the new thread
    public void run() {
        System.out.println(threadName + " is running.");
        try {
            for (int i = 0; i < 5; i++) {
                System.out.println(threadName + ": " + i);
                Thread.sleep(500); // Pause for 500 milliseconds
            }
        } catch (InterruptedException e) {
            System.out.println(threadName + " was interrupted.");
        }
        System.out.println(threadName + " finished.");
    }
}

public class ThreadExtensionExample {
    public static void main(String[] args) {
        System.out.println("Main thread starts.");

        // Step 3: Create instances of our custom thread class
        MyThread thread1 = new MyThread("Thread-1");
        MyThread thread2 = new MyThread("Thread-2");

        // Step 4: Call start() to begin execution in a new thread
        thread1.start(); // This calls the run() method in a new, separate thread
        thread2.start(); // This calls the run() method in another new, separate thread

        System.out.println("Main thread continues (and might finish before child threads).");
        // The main thread will continue executing concurrently with thread1 and thread2.
    }
}
```

**Limitation:** Since Java does not support multiple inheritance, your class cannot extend any other class if it's already extending `Thread`.

### b) By Implementing the `Runnable` Interface

1.  Create a class that `implements java.lang.Runnable`.
2.  Override the `public void run()` method.
3.  Create an instance of your `Runnable` implementation.
4.  Create a `Thread` object, passing your `Runnable` instance to its constructor.
5.  Call the `start()` method on the `Thread` object.

**Example 2: Implementing `Runnable`**

```java
// Step 1 & 2: Create a class that implements Runnable and override run()
class MyRunnable implements Runnable {
    private String taskName;

    public MyRunnable(String name) {
        this.taskName = name;
        System.out.println(taskName + " is being prepared.");
    }

    @Override // This method contains the code that will run in the new thread
    public void run() {
        System.out.println(taskName + " is executing.");
        try {
            for (int i = 0; i < 3; i++) {
                System.out.println(taskName + " working: " + i);
                Thread.sleep(700); // Pause for 700 milliseconds
            }
        } catch (InterruptedException e) {
            System.out.println(taskName + " was interrupted.");
        }
        System.out.println(taskName + " finished.");
    }
}

public class RunnableImplementationExample {
    public static void main(String[] args) {
        System.out.println("Main thread starts.");

        // Step 3: Create instances of our custom Runnable
        MyRunnable runnable1 = new MyRunnable("Task-A");
        MyRunnable runnable2 = new MyRunnable("Task-B");

        // Step 4: Create Thread objects, passing the Runnable instances
        Thread threadA = new Thread(runnable1);
        Thread threadB = new Thread(runnable2);

        // Step 5: Call start() on the Thread objects
        threadA.start();
        threadB.start();

        System.out.println("Main thread continues and might finish.");
    }
}
```

**Advantage:** This is generally the **preferred way** to create threads because your class can still extend another class while implementing `Runnable`, adhering to Java's single inheritance model.

---

## 6. The `run()` vs. `start()` Distinction (Crucial!)

This is a common point of confusion for beginners:

* **`thread.start()`:** This is the correct method to call.
    * It performs essential setup for a new thread (e.g., allocating resources for the new thread).
    * It then invokes the `run()` method in this **newly created separate thread of execution**.
    * The `start()` method itself returns immediately, and the original thread (e.g., the `main` thread) continues its execution concurrently.
* **`thread.run()`:** If you directly call `thread.run()`, the `run()` method will be executed just like any other normal method call.
    * It will **NOT** create a new thread.
    * The code inside `run()` will execute in the **current thread** (e.g., the `main` thread), sequentially.
    * The original thread will wait for `run()` to complete before it proceeds. This defeats the purpose of multithreading.

**Think of it:** `start()` *starts* a new vehicle (thread) on its own journey, while `run()` just tells the *current* vehicle to take a specific route.

---

## 7. Thread Lifecycle (Briefly)

A thread goes through various states during its lifetime:

1.  **New:** When a `Thread` instance is created but `start()` has not yet been called.
2.  **Runnable:** After `start()` is called, the thread is ready to run. It's waiting for the CPU to assign it time.
3.  **Running:** The thread is actively executing its `run()` method.
4.  **Blocked/Waiting/Timed Waiting:** The thread is temporarily inactive because it's waiting for some event (e.g., I/O operation to complete, a lock to be released, `sleep()` delay to finish, `join()` to complete).
5.  **Terminated:** The `run()` method has completed, or the thread has exited due to an unhandled exception. The thread is dead and cannot be restarted.

---

## 8. Thread Synchronization (The "Hard" Part - Beginner Introduction)

When multiple threads share resources (like a common variable, a file, or a database connection), problems can arise if they try to access or modify the resource at the same time. This is called a **race condition**.

**The Problem:** Unpredictable and incorrect results due to concurrent access to shared data.

**Example 3: Race Condition (without synchronization)**

```java
class Counter {
    int count = 0;

    public void increment() {
        count++; // This is not an atomic operation (read, modify, write)
    }

    public int getCount() {
        return count;
    }
}

class CounterThread extends Thread {
    private Counter counter;

    public CounterThread(Counter counter) {
        this.counter = counter;
    }

    @Override
    public void run() {
        for (int i = 0; i < 1000; i++) {
            counter.increment();
        }
    }
}

public class RaceConditionExample {
    public static void main(String[] args) throws InterruptedException {
        Counter counter = new Counter();
        CounterThread t1 = new CounterThread(counter);
        CounterThread t2 = new CounterThread(counter);

        t1.start();
        t2.start();

        // Wait for both threads to finish
        t1.join(); // The main thread waits for t1 to die
        t2.join(); // The main thread waits for t2 to die

        // Expected output: 2000 (1000 from t1 + 1000 from t2)
        // Actual output: Likely less than 2000, due to race conditions
        System.out.println("Final counter value: " + counter.getCount());
    }
}
```
**Explanation:** When `count++` executes, it involves three steps:
1.  Read the current value of `count`.
2.  Increment the value.
3.  Write the new value back to `count`.
If `t1` reads `count` as 50, and then `t2` also reads `count` as 50 *before* `t1` writes back 51, both `t1` and `t2` will increment their read value (50) to 51 and write it back. This causes one increment to be lost.

**Solution: Synchronization**

Synchronization is the mechanism to ensure that only one thread can execute a particular section of code (called a "critical section") at a time, thereby preventing race conditions. In Java, the `synchronized` keyword is used for this.

### `synchronized` Methods and Blocks:

* **`synchronized` method:** If you declare a method as `synchronized`, only one thread can execute that method on a given object at any given time. Other threads trying to call a `synchronized` method on the *same object* will wait.

    ```java
    class SynchronizedCounter {
        int count = 0;

        public synchronized void increment() { // Method is synchronized
            count++;
        }

        public int getCount() {
            return count;
        }
    }

    // (Use the same CounterThread as above, but with SynchronizedCounter)
    // In main:
    // SynchronizedCounter counter = new SynchronizedCounter();
    // CounterThread t1 = new CounterThread(counter);
    // CounterThread t2 = new CounterThread(counter);
    // ... rest is same. This time, output will consistently be 2000.
    ```

* **`synchronized` block:** This allows you to synchronize on a specific object (the "lock") and only protect a specific block of code, rather than the entire method. This gives finer-grained control and can improve performance.

    ```java
    class SynchronizedBlockCounter {
        int count = 0;
        private final Object lock = new Object(); // A dedicated lock object

        public void increment() {
            synchronized (lock) { // Synchronize on the 'lock' object
                count++;
            }
        }

        public int getCount() {
            return count;
        }
    }
    // (Usage in main is similar to SynchronizedCounter)
    ```
    For `synchronized` methods, the lock is the `this` object (the current instance). For static synchronized methods, the lock is the class object itself.

**Other Synchronization Tools:**
* `wait()`, `notify()`, `notifyAll()`: Used for inter-thread communication, allowing threads to wait for certain conditions and be notified when those conditions are met. (More advanced topic)
* `java.util.concurrent.locks.Lock` interface: Provides more flexible and explicit locking mechanisms than the `synchronized` keyword. (More advanced topic)

---

## 9. Common Thread Methods (Briefly)

* `Thread.currentThread()`: Returns a reference to the currently executing thread object.
* `Thread.sleep(long millis)`: Causes the currently executing thread to pause for the specified number of milliseconds.
* `thread.join()`: Causes the current thread to wait until the thread it's joining with terminates. (Used in `RaceConditionExample` to ensure main waits for worker threads).
* `thread.interrupt()`: Interrupts the specified thread. This doesn't stop the thread immediately, but sets an "interrupted" flag and can cause `InterruptedException` if the thread is in a waiting/sleeping state.

---

## 10. Modern Concurrency (`java.util.concurrent` package)

While `Thread` and `Runnable` are fundamental, for more complex multithreaded applications, especially those involving thread pools, task submission, and returning results from tasks, the `java.util.concurrent` package (introduced in Java 5) is highly recommended.

Key components include:
* `ExecutorService`: Manages a pool of threads for executing tasks.
* `Callable` and `Future`: Represent tasks that return a result and/or throw an exception.
* Concurrency utilities like `Semaphore`, `CountDownLatch`, `CyclicBarrier`, `BlockingQueue`.

These classes provide higher-level abstractions that reduce the complexity and common pitfalls of direct thread management.

---

## Conclusion

Multithreading in Java is a powerful tool for building responsive and efficient applications, especially on modern multi-core processors. While it offers significant benefits, it also introduces challenges like race conditions and deadlocks that require careful synchronization. Understanding the basics of thread creation, the `start()` vs. `run()` distinction, and the need for synchronization is key to writing correct and robust multithreaded Java programs.

-----------------------------------------------------------------------------------------------------------------------------------------------------------

Packages in Java 

In Java, a Package is a mechanism used to group related classes, interfaces, and sub-packages together.1Think of it exactly like a folder (directory) on your computer. Just as you organize your files into folders (e.g., Photos, Documents, Downloads) to keep them tidy and avoid name clashes, Java uses packages to organize code.21. Why do we need Packages?Packages solve three major problems in programming:Preventing Naming Conflicts:Two different programmers might both create a class named User. If they are in the same folder, this causes an error. If one is in com.google.User and the other in com.facebook.User, they can exist peacefully in the same project.3Access Protection (Encapsulation):As we discussed in your previous question, if you don't give a variable an access modifier, it is package-private.4 This allows all classes inside the same package to share data while hiding it from the rest of the world.Code Organization:It makes navigating large projects easier.5 You can group all database code in one package and all UI code in another.62. Physical Structure vs. Logical StructureThere is a direct 1-to-1 mapping between the package name and your folder structure on the hard drive.7If you declare a package named com.example.game:Logical Name: com.example.gamePhysical Path: ...\com\example\game\3. Syntax and RulesTo put a class into a package, you use the package keyword as the very first line of your Java file.File: 

Player.javaJavapackage com.example.game; // Must be the first line

public class Player {
    // Class code here
}
To use a class from another package, you must import it:Javapackage com.example.reporting;

// We need to import Player because it is in a different package
import com.example.game.Player; 

public class ScoreBoard {
    Player p = new Player(); 
}
4. Naming Convention (The Reverse Domain Rule)8To ensure every package in the world is unique, Java developers follow a strict convention: Reverse Internet Domain Name.9If your company owns the website mycompany.com, your packages should start with com.mycompany.WebsitePackage PrefixSpecific ModuleResulting Packagehttps://www.google.com/search?q=google.comcom.googlemapscom.google.mapsapache.orgorg.apachecommonsorg.apache.commonsjava.comjavautil (utility)java.util5. Types of PackagesBuilt-in Packages (The Java API): These come pre-installed with Java.10java.lang: Fundamental classes (String, System).11 You never need to import this; Java imports it automatically.java.util: Utility classes (ArrayList, Date).12java.io: Input/Output (File reading/writing).13User-Defined Packages: These are the packages you create for your own project.1
----------------------------------------------------------------------------------------------------------------------------------------

give an example of my own package in java ? 

To create your own package, you need to match your folder structure to your package name.

Let's create a simple package called com.myapp.math that contains a Calculator class, and then we will use it in a main program.

Step 1: Create the Directory Structure
First, you must create folders that match the package dots.

Create a folder named com.

Inside com, create a folder named myapp.

Inside myapp, create a folder named math.

Path: .../com/myapp/math/

Step 2: Create the Class Inside the Package
Create a file named Calculator.java inside the math folder.

File: com/myapp/math/Calculator.java

Java

// 1. Declare the package (Must match the folder path)
package com.myapp.math;

public class Calculator {
    
    // We use 'public' so this method is visible outside this package
    public int add(int a, int b) {
        return a + b;
    }

    public void sayHello() {
        System.out.println("Hello from the Math Package!");
    }
}
Step 3: Create a Main Class to Use It
Now, go back to your root folder (outside of com) or create a new folder for your main app. Let's create Main.java at the root level.

File: Main.java

Java

// We have no package declaration here, so this is the "default package"

// 2. Import the class we created
import com.myapp.math.Calculator;

public class Main {
    public static void main(String[] args) {
        
        // 3. Create an object of the imported class
        Calculator calc = new Calculator();
        
        calc.sayHello();
        int result = calc.add(10, 5);
        
        System.out.println("The sum is: " + result);
    }
}
Step 4: Compiling and Running
This is where many beginners get stuck. You should compile from the root directory (where Main.java is), not from inside the package folders.

Open your terminal/command prompt at the root folder and run:

Compile:

Bash

javac Main.java
(Note: Java is smart enough to find and compile com/myapp/math/Calculator.java automatically because you imported it.)

Run:

Bash

java Main
Output:

Plaintext

Hello from the Math Package!
The sum is: 15
Summary Checklist
Folder: com/myapp/math

Package Line: package com.myapp.math; (First line of Calculator.java)

Import Line: import com.myapp.math.Calculator;

--------------------------------------------------------------------------------------------------------------------------------------------------------------
